Enter your prompt here

# Project Structure

â”œâ”€ ðŸ“ scripts
  â””â”€ cleanup.sh
  â””â”€ setup-local.sh
  â””â”€ setup-azure.sh
  â””â”€ docker-wsl.ps1
  â””â”€ dev-start.sh
  â””â”€ deploy.sh
  â””â”€ deploy-local.sh
â”œâ”€ ðŸ“ infrastructure
  â”œâ”€ ðŸ“ terraform
    â”œâ”€ ðŸ“ .terraform
      â”œâ”€ ðŸ“ modules
        â””â”€ modules.json
      â”œâ”€ ðŸ“ providers
        â”œâ”€ ðŸ“ registry.terraform.io
          â”œâ”€ ðŸ“ hashicorp
            â”œâ”€ ðŸ“ random
              â”œâ”€ ðŸ“ 3.6.3
                â”œâ”€ ðŸ“ windows_amd64
                  â””â”€ LICENSE.txt
    â”œâ”€ ðŸ“ modules
      â”œâ”€ ðŸ“ registry
        â””â”€ variables.tf
        â””â”€ outputs.tf
        â””â”€ main.tf
      â”œâ”€ ðŸ“ monitoring
        â””â”€ variables.tf
        â””â”€ outputs.tf
        â””â”€ main.tf
      â”œâ”€ ðŸ“ networking
        â””â”€ variables.tf
        â””â”€ outputs.tf
        â””â”€ main.tf
      â”œâ”€ ðŸ“ keyvault
        â””â”€ variables.tf
        â””â”€ outputs.tf
        â””â”€ main.tf
      â”œâ”€ ðŸ“ database
        â””â”€ variables.tf
        â””â”€ outputs.tf
        â””â”€ main.tf
      â”œâ”€ ðŸ“ container-apps
        â””â”€ variables.tf
        â””â”€ outputs.tf
        â””â”€ main.tf
      â”œâ”€ ðŸ“ cache
        â””â”€ variables.tf
        â””â”€ outputs.tf
        â””â”€ main.tf
    â””â”€ variables.tf
    â””â”€ tfplan
    â””â”€ terraform.tfvars
    â””â”€ terraform.tfstate.backup
    â””â”€ terraform.tfstate
    â””â”€ providers.tf
    â””â”€ outputs.tf
    â””â”€ main.tf
    â””â”€ backend.tf
â”œâ”€ ðŸ“ prisma
  â”œâ”€ ðŸ“ seeds
    â””â”€ standards.seed.ts
  â”œâ”€ ðŸ“ migrations
    â”œâ”€ ðŸ“ 20260125000000_initial
      â””â”€ migration.sql
    â””â”€ migration_lock.toml
  â””â”€ seed.ts
  â””â”€ schema.prisma
â”œâ”€ ðŸ“ libs
  â”œâ”€ ðŸ“ shared
    â”œâ”€ ðŸ“ src
      â”œâ”€ ðŸ“ dto
        â””â”€ response.dto.d.ts
        â””â”€ pagination.dto.ts
        â””â”€ pagination.dto.js
        â””â”€ pagination.dto.d.ts
        â””â”€ response.dto.ts
        â””â”€ response.dto.js
      â””â”€ index.ts
      â””â”€ index.js
      â””â”€ index.d.ts
    â””â”€ tsconfig.json
    â””â”€ package.json
  â”œâ”€ ðŸ“ database
    â”œâ”€ ðŸ“ src
      â””â”€ prisma.module.d.ts
      â””â”€ index.ts
      â””â”€ index.js
      â””â”€ index.d.ts
      â””â”€ prisma.service.ts
      â””â”€ prisma.service.js
      â””â”€ prisma.service.d.ts
      â””â”€ prisma.module.ts
      â””â”€ prisma.module.js
    â””â”€ tsconfig.json
    â””â”€ package.json
  â”œâ”€ ðŸ“ redis
    â”œâ”€ ðŸ“ src
      â””â”€ redis.service.ts
      â””â”€ redis.service.js
      â””â”€ redis.service.d.ts
      â””â”€ redis.module.ts
      â””â”€ redis.module.js
      â””â”€ redis.module.d.ts
      â””â”€ index.ts
      â””â”€ index.js
      â””â”€ index.d.ts
    â””â”€ tsconfig.json
    â””â”€ package.json
â”œâ”€ ðŸ“ docs
  â”œâ”€ ðŸ“ questionnaire
    â””â”€ question-bank.md
    â””â”€ industry-templates.md
    â””â”€ adaptive-logic.md
  â”œâ”€ ðŸ“ ba
    â””â”€ 06-stakeholder-analysis.md
    â””â”€ 08-wireframes-mockups.md
    â””â”€ 07-business-case.md
    â””â”€ 05-requirements-traceability-matrix.md
    â””â”€ 04-user-stories-use-cases.md
    â””â”€ 03-process-maps-flowcharts.md
    â””â”€ 02-functional-requirements-document.md
    â””â”€ 01-business-requirements-document.md
    â””â”€ 09-change-request-document.md
  â”œâ”€ ðŸ“ cto
    â””â”€ 15-ip-assignment-nda.md
    â””â”€ 14-onboarding-offboarding-procedures.md
    â””â”€ 13-vendor-management.md
    â””â”€ 12-engineering-handbook.md
    â””â”€ 11-disaster-recovery-business-continuity.md
    â””â”€ 10-data-protection-privacy-policy.md
    â””â”€ 09-incident-response-plan.md
    â””â”€ 08-information-security-policy.md
    â””â”€ 07-technical-debt-register.md
    â””â”€ 06-user-flow-journey-maps.md
    â””â”€ 05-data-models-db-architecture.md
    â””â”€ 04-api-documentation.md
    â””â”€ 03-product-architecture.md
    â””â”€ 02-technology-strategy.md
    â””â”€ 01-technology-roadmap.md
  â”œâ”€ ðŸ“ cfo
    â””â”€ business-plan.md
  â””â”€ quest-prompts.md
â”œâ”€ ðŸ“ docker
  â”œâ”€ ðŸ“ api
    â””â”€ entrypoint.sh
    â””â”€ Dockerfile
  â”œâ”€ ðŸ“ postgres
    â””â”€ init.sql
â”œâ”€ ðŸ“ apps
  â”œâ”€ ðŸ“ api
    â”œâ”€ ðŸ“ test
      â””â”€ jest-e2e.json
    â”œâ”€ ðŸ“ src
      â”œâ”€ ðŸ“ modules
        â”œâ”€ ðŸ“ users
          â”œâ”€ ðŸ“ dto
            â””â”€ update-user.dto.ts
          â””â”€ users.service.ts
          â””â”€ users.service.spec.ts
          â””â”€ users.module.ts
          â””â”€ users.controller.ts
        â”œâ”€ ðŸ“ questionnaire
          â””â”€ questionnaire.service.ts
          â””â”€ questionnaire.service.spec.ts
          â””â”€ questionnaire.module.ts
          â””â”€ questionnaire.controller.ts
        â”œâ”€ ðŸ“ session
          â”œâ”€ ðŸ“ dto
            â””â”€ submit-response.dto.ts
            â””â”€ create-session.dto.ts
            â””â”€ continue-session.dto.ts
          â””â”€ session.service.ts
          â””â”€ session.service.spec.ts
          â””â”€ session.module.ts
          â””â”€ session.controller.ts
        â”œâ”€ ðŸ“ standards
          â”œâ”€ ðŸ“ dto
            â””â”€ standard.dto.ts
          â”œâ”€ ðŸ“ types
            â””â”€ standard.types.ts
          â””â”€ standards.service.ts
          â””â”€ standards.service.spec.ts
          â””â”€ standards.module.ts
          â””â”€ standards.controller.ts
        â”œâ”€ ðŸ“ auth
          â”œâ”€ ðŸ“ strategies
            â””â”€ jwt.strategy.ts
          â”œâ”€ ðŸ“ guards
            â””â”€ roles.guard.ts
            â””â”€ jwt-auth.guard.ts
          â”œâ”€ ðŸ“ dto
            â””â”€ login.dto.ts
            â””â”€ token.dto.ts
            â””â”€ register.dto.ts
            â””â”€ refresh-token.dto.ts
          â”œâ”€ ðŸ“ decorators
            â””â”€ user.decorator.ts
            â””â”€ roles.decorator.ts
            â””â”€ public.decorator.ts
          â””â”€ auth.service.ts
          â””â”€ auth.service.spec.ts
          â””â”€ auth.module.ts
          â””â”€ auth.controller.ts
        â”œâ”€ ðŸ“ admin
          â”œâ”€ ðŸ“ services
            â””â”€ admin-audit.service.ts
            â””â”€ admin-questionnaire.service.ts
          â”œâ”€ ðŸ“ tests
            â””â”€ admin-questionnaire.service.spec.ts
          â”œâ”€ ðŸ“ dto
            â””â”€ update-question.dto.ts
            â””â”€ update-questionnaire.dto.ts
            â””â”€ reorder-sections.dto.ts
            â””â”€ reorder-questions.dto.ts
            â””â”€ index.ts
            â””â”€ create-visibility-rule.dto.ts
            â””â”€ create-section.dto.ts
            â””â”€ create-questionnaire.dto.ts
            â””â”€ update-section.dto.ts
            â””â”€ create-question.dto.ts
            â””â”€ update-visibility-rule.dto.ts
          â”œâ”€ ðŸ“ controllers
            â””â”€ admin-questionnaire.controller.ts
          â””â”€ admin.module.ts
        â”œâ”€ ðŸ“ document-generator
          â”œâ”€ ðŸ“ tests
            â””â”€ template-engine.service.spec.ts
          â”œâ”€ ðŸ“ services
            â””â”€ template-engine.service.ts
            â””â”€ storage.service.ts
            â””â”€ document-generator.service.ts
          â”œâ”€ ðŸ“ templates
            â””â”€ base.template.ts
          â”œâ”€ ðŸ“ dto
            â””â”€ document-response.dto.ts
            â””â”€ create-document-type.dto.ts
            â””â”€ update-document-type.dto.ts
            â””â”€ review-document.dto.ts
            â””â”€ request-generation.dto.ts
            â””â”€ index.ts
          â”œâ”€ ðŸ“ controllers
            â””â”€ document.controller.ts
            â””â”€ document-admin.controller.ts
          â””â”€ document-generator.module.ts
        â”œâ”€ ðŸ“ adaptive-logic
          â”œâ”€ ðŸ“ types
            â””â”€ rule.types.ts
          â”œâ”€ ðŸ“ evaluators
            â””â”€ condition.evaluator.spec.ts
            â””â”€ condition.evaluator.ts
          â””â”€ adaptive-logic.service.ts
          â””â”€ adaptive-logic.service.spec.ts
          â””â”€ adaptive-logic.module.ts
      â”œâ”€ ðŸ“ common
        â”œâ”€ ðŸ“ interceptors
          â””â”€ transform.interceptor.ts
          â””â”€ logging.interceptor.ts
        â”œâ”€ ðŸ“ filters
          â””â”€ http-exception.filter.ts
      â”œâ”€ ðŸ“ config
        â””â”€ configuration.ts
      â””â”€ main.ts
      â””â”€ health.controller.ts
      â””â”€ app.module.ts
    â””â”€ tsconfig.json
    â””â”€ package.json
    â””â”€ package-lock.json
    â””â”€ nest-cli.json
â”œâ”€ ðŸ“ .qoder
  â”œâ”€ ðŸ“ repowiki
    â”œâ”€ ðŸ“ en
      â”œâ”€ ðŸ“ content
        â”œâ”€ ðŸ“ Deployment and Infrastructure
          â””â”€ Terraform Infrastructure.md
          â””â”€ Docker Containerization.md
          â””â”€ Deployment and Infrastructure.md
          â””â”€ CI_CD Pipeline.md
        â”œâ”€ ðŸ“ Shared Libraries
          â””â”€ Database Library.md
          â””â”€ Redis Library.md
          â””â”€ Shared DTO Library.md
          â””â”€ Shared Libraries.md
        â”œâ”€ ðŸ“ Advanced Topics
          â””â”€ System Customization.md
          â””â”€ Security Hardening.md
          â””â”€ Question Type Extensions.md
          â””â”€ Performance Optimization.md
          â””â”€ Custom Rule Development.md
          â””â”€ Advanced Topics.md
        â”œâ”€ ðŸ“ Core Modules
          â””â”€ User Management Module.md
          â””â”€ Standards Module.md
          â””â”€ Session Module.md
          â””â”€ Questionnaire Module.md
          â””â”€ Core Modules.md
          â””â”€ Authentication Module.md
          â””â”€ Adaptive Logic Module.md
        â”œâ”€ ðŸ“ API Reference
          â””â”€ User Management Endpoints.md
          â””â”€ Standards Endpoints.md
          â””â”€ Session Endpoints.md
          â””â”€ Questionnaire Endpoints.md
          â””â”€ Authentication Endpoints.md
          â””â”€ API Reference.md
        â”œâ”€ ðŸ“ Architecture Overview
          â””â”€ System Design.md
          â””â”€ Design Patterns.md
          â””â”€ Data Flow Architecture.md
          â””â”€ Component Interactions.md
          â””â”€ Architecture Overview.md
        â””â”€ Getting Started.md
        â””â”€ Project Overview.md
        â””â”€ Monitoring and Maintenance.md
        â””â”€ Development Guidelines.md
        â””â”€ Troubleshooting and FAQ.md
        â””â”€ Database Management.md
        â””â”€ Data Models and Database Schema.md
        â””â”€ Configuration and Environment.md
      â”œâ”€ ðŸ“ meta
        â””â”€ repowiki-metadata.json
â”œâ”€ ðŸ“ .turbo
  â”œâ”€ ðŸ“ cookies
    â””â”€ 5.cookie
    â””â”€ 4.cookie
    â””â”€ 3.cookie
    â””â”€ 2.cookie
â””â”€ .dockerignore
â””â”€ .prettierrc
â””â”€ turbo.json
â””â”€ tsconfig.json
â””â”€ package.json
â””â”€ package-lock.json
â””â”€ docker-test.js
â””â”€ docker-compose.yml
â””â”€ azure-pipelines.yml
â””â”€ .swcrc
â””â”€ .eslintrc.js


# Project Files

- c:\Users\avi\OneDrive - BAS & More\Qoder Repo\Quiz-to-build\Quiz-to-build\scripts\deploy.sh
- c:\Users\avi\OneDrive - BAS & More\Qoder Repo\Quiz-to-build\Quiz-to-build\docker-compose.yml
- c:\Users\avi\OneDrive - BAS & More\Qoder Repo\Quiz-to-build\Quiz-to-build\scripts\docker-wsl.ps1
- c:\Users\avi\OneDrive - BAS & More\Qoder Repo\Quiz-to-build\Quiz-to-build\.dockerignore
- c:\Users\avi\OneDrive - BAS & More\Qoder Repo\Quiz-to-build\Quiz-to-build\libs\shared\src\dto\response.dto.ts
- c:\Users\avi\OneDrive - BAS & More\Qoder Repo\Quiz-to-build\Quiz-to-build\apps\api\tsconfig.json
- c:\Users\avi\OneDrive - BAS & More\Qoder Repo\Quiz-to-build\Quiz-to-build\tsconfig.json
- c:\Users\avi\OneDrive - BAS & More\Qoder Repo\Quiz-to-build\Quiz-to-build\apps\api\src\modules\standards\standards.service.ts
- c:\Users\avi\OneDrive - BAS & More\Qoder Repo\Quiz-to-build\Quiz-to-build\apps\api\src\modules\standards\standards.service.spec.ts
- c:\Users\avi\OneDrive - BAS & More\Qoder Repo\Quiz-to-build\Quiz-to-build\apps\api\src\modules\standards\dto\standard.dto.ts
- c:\Users\avi\OneDrive - BAS & More\Qoder Repo\Quiz-to-build\Quiz-to-build\apps\api\src\modules\session\session.service.ts
- c:\Users\avi\OneDrive - BAS & More\Qoder Repo\Quiz-to-build\Quiz-to-build\apps\api\src\modules\session\session.service.spec.ts
- c:\Users\avi\OneDrive - BAS & More\Qoder Repo\Quiz-to-build\Quiz-to-build\apps\api\nest-cli.json
- c:\Users\avi\OneDrive - BAS & More\Qoder Repo\Quiz-to-build\Quiz-to-build\apps\api\src\modules\admin\services\admin-audit.service.ts
- c:\Users\avi\OneDrive - BAS & More\Qoder Repo\Quiz-to-build\Quiz-to-build\apps\api\src\modules\admin\services\admin-questionnaire.service.ts
- c:\Users\avi\OneDrive - BAS & More\Qoder Repo\Quiz-to-build\Quiz-to-build\apps\api\src\modules\document-generator\controllers\document-admin.controller.ts
- c:\Users\avi\OneDrive - BAS & More\Qoder Repo\Quiz-to-build\Quiz-to-build\apps\api\src\modules\document-generator\controllers\document.controller.ts
- c:\Users\avi\OneDrive - BAS & More\Qoder Repo\Quiz-to-build\Quiz-to-build\apps\api\package.json
- c:\Users\avi\OneDrive - BAS & More\Qoder Repo\Quiz-to-build\Quiz-to-build\apps\api\src\modules\document-generator\services\document-builder.service.ts
- c:\Users\avi\OneDrive - BAS & More\Qoder Repo\Quiz-to-build\Quiz-to-build\docker\api\Dockerfile
- c:\Users\avi\OneDrive - BAS & More\Qoder Repo\Quiz-to-build\Quiz-to-build\infrastructure\terraform\modules\database\main.tf
- c:\Users\avi\OneDrive - BAS & More\Qoder Repo\Quiz-to-build\Quiz-to-build\infrastructure\terraform\providers.tf
- c:\Users\avi\OneDrive - BAS & More\Qoder Repo\Quiz-to-build\Quiz-to-build\infrastructure\terraform\variables.tf
- c:\Users\avi\OneDrive - BAS & More\Qoder Repo\Quiz-to-build\Quiz-to-build\.gitignore
- c:\Users\avi\OneDrive - BAS & More\Qoder Repo\Quiz-to-build\Quiz-to-build\.vscode\settings.json
- c:\Users\avi\OneDrive - BAS & More\Qoder Repo\Quiz-to-build\Quiz-to-build\apps\api\src\modules\adaptive-logic\adaptive-logic.service.ts

## c:\Users\avi\OneDrive - BAS & More\Qoder Repo\Quiz-to-build\Quiz-to-build\scripts\deploy.sh
```
#!/bin/bash
# =============================================================================
# Azure Deployment Script
# Deploys the Adaptive Questionnaire System to Azure
# =============================================================================

set -e

# Colors for output
RED='\033[0;31m'
GREEN='\033[0;32m'
YELLOW='\033[1;33m'
BLUE='\033[0;34m'
NC='\033[0m' # No Color

echo -e "${GREEN}=============================================${NC}"
echo -e "${GREEN}  Azure Deployment                            ${NC}"
echo -e "${GREEN}  Adaptive Questionnaire System               ${NC}"
echo -e "${GREEN}=============================================${NC}"

# Get script directory
SCRIPT_DIR="$(cd "$(dirname "${BASH_SOURCE[0]}")" && pwd)"
PROJECT_ROOT="$SCRIPT_DIR/.."
TERRAFORM_DIR="$PROJECT_ROOT/infrastructure/terraform"

# Check prerequisites
echo -e "\n${YELLOW}Step 1: Checking prerequisites...${NC}"

if ! az account show &> /dev/null; then
    echo -e "${RED}Error: Not logged in to Azure. Run 'az login' first.${NC}"
    exit 1
fi

if [ ! -f "$TERRAFORM_DIR/terraform.tfvars" ]; then
    echo -e "${RED}Error: terraform.tfvars not found. Run ./scripts/setup-azure.sh first.${NC}"
    exit 1
fi

echo -e "${GREEN}Prerequisites check passed.${NC}"

# Initialize Terraform
echo -e "\n${YELLOW}Step 2: Initializing Terraform...${NC}"
cd "$TERRAFORM_DIR"
terraform init -upgrade

# Validate Terraform configuration
echo -e "\n${YELLOW}Step 3: Validating Terraform configuration...${NC}"
terraform validate

# Plan Terraform changes
echo -e "\n${YELLOW}Step 4: Planning infrastructure changes...${NC}"
terraform plan -out=tfplan

# Prompt for confirmation
echo -e "\n${BLUE}Review the plan above. Continue with deployment? (yes/no)${NC}"
read -r CONFIRM
if [ "$CONFIRM" != "yes" ]; then
    echo -e "${YELLOW}Deployment cancelled.${NC}"
    exit 0
fi

# Apply Terraform changes
echo -e "\n${YELLOW}Step 5: Applying infrastructure changes...${NC}"
echo -e "${YELLOW}This may take 10-15 minutes...${NC}"
terraform apply tfplan

# Get outputs
echo -e "\n${YELLOW}Step 6: Retrieving deployment outputs...${NC}"
ACR_NAME=$(terraform output -raw acr_name)
ACR_LOGIN_SERVER=$(terraform output -raw acr_login_server)
RESOURCE_GROUP=$(terraform output -raw resource_group_name)
CONTAINER_APP_NAME=$(terraform output -raw api_container_app_name)
API_URL=$(terraform output -raw api_url)

echo -e "${GREEN}Infrastructure deployed successfully!${NC}"

# Build Docker image
echo -e "\n${YELLOW}Step 7: Building Docker image...${NC}"
cd "$PROJECT_ROOT"
docker build \
    -t "$ACR_LOGIN_SERVER/questionnaire-api:latest" \
    -f docker/api/Dockerfile \
    --target production \
    .

# Login to ACR
echo -e "\n${YELLOW}Step 8: Logging in to Azure Container Registry...${NC}"
az acr login --name "$ACR_NAME"

# Push Docker image
echo -e "\n${YELLOW}Step 9: Pushing Docker image to ACR...${NC}"
docker push "$ACR_LOGIN_SERVER/questionnaire-api:latest"

# Update Container App with new image
echo -e "\n${YELLOW}Step 10: Updating Container App...${NC}"
az containerapp update \
    --name "$CONTAINER_APP_NAME" \
    --resource-group "$RESOURCE_GROUP" \
    --image "$ACR_LOGIN_SERVER/questionnaire-api:latest"

# Wait for deployment
echo -e "\n${YELLOW}Waiting for deployment to complete...${NC}"
sleep 30

# Run database migrations
echo -e "\n${YELLOW}Step 11: Running database migrations...${NC}"
az containerapp exec \
    --name "$CONTAINER_APP_NAME" \
    --resource-group "$RESOURCE_GROUP" \
    --command "npx prisma migrate deploy" || {
    echo -e "${YELLOW}Warning: Could not run migrations via exec. You may need to run them manually.${NC}"
}

# Health check
echo -e "\n${YELLOW}Step 12: Performing health check...${NC}"
for i in {1..12}; do
    HTTP_CODE=$(curl -s -o /dev/null -w "%{http_code}" "$API_URL/api/v1/health" || echo "000")
    if [ "$HTTP_CODE" = "200" ]; then
        echo -e "${GREEN}Health check passed!${NC}"
        break
    fi
    echo "Attempt $i/12: HTTP $HTTP_CODE, waiting 10 seconds..."
    sleep 10
done

if [ "$HTTP_CODE" != "200" ]; then
    echo -e "${YELLOW}Warning: Health check did not return 200. Check the logs.${NC}"
    echo -e "${YELLOW}The deployment completed but the API may need more time to start.${NC}"
fi

# Print summary
echo -e "\n${GREEN}=============================================${NC}"
echo -e "${GREEN}  Deployment Complete!                        ${NC}"
echo -e "${GREEN}=============================================${NC}"
echo -e "\n${BLUE}Application URLs:${NC}"
echo -e "  API Base:     ${API_URL}"
echo -e "  Health Check: ${API_URL}/api/v1/health"
echo -e "  Swagger Docs: ${API_URL}/docs"
echo -e "  API v1:       ${API_URL}/api/v1"
echo -e "\n${BLUE}Azure Resources:${NC}"
echo -e "  Resource Group:  ${RESOURCE_GROUP}"
echo -e "  Container App:   ${CONTAINER_APP_NAME}"
echo -e "  Registry:        ${ACR_LOGIN_SERVER}"
echo -e "\n${BLUE}Useful commands:${NC}"
echo -e "  View logs:       az containerapp logs show --name ${CONTAINER_APP_NAME} --resource-group ${RESOURCE_GROUP} --follow"
echo -e "  View revisions:  az containerapp revision list --name ${CONTAINER_APP_NAME} --resource-group ${RESOURCE_GROUP}"
echo -e "  SSH into app:    az containerapp exec --name ${CONTAINER_APP_NAME} --resource-group ${RESOURCE_GROUP}"

```

## c:\Users\avi\OneDrive - BAS & More\Qoder Repo\Quiz-to-build\Quiz-to-build\docker-compose.yml
```
services:
  postgres:
    image: postgres:15-alpine
    container_name: questionnaire-postgres
    restart: unless-stopped
    environment:
      POSTGRES_USER: postgres
      POSTGRES_PASSWORD: postgres
      POSTGRES_DB: questionnaire
    ports:
      - "5432:5432"
    volumes:
      - postgres_data:/var/lib/postgresql/data
      - ./docker/postgres/init.sql:/docker-entrypoint-initdb.d/init.sql:ro
    healthcheck:
      test: [ "CMD-SHELL", "pg_isready -U postgres" ]
      interval: 10s
      timeout: 5s
      retries: 5
    networks:
      - questionnaire-network

  redis:
    image: redis:7-alpine
    container_name: questionnaire-redis
    restart: unless-stopped
    ports:
      - "6379:6379"
    volumes:
      - redis_data:/data
    healthcheck:
      test: [ "CMD", "redis-cli", "ping" ]
      interval: 10s
      timeout: 5s
      retries: 5
    command: redis-server --appendonly yes
    networks:
      - questionnaire-network

  api:
    build:
      context: .
      dockerfile: docker/api/Dockerfile
      target: development
    container_name: questionnaire-api
    restart: unless-stopped
    ports:
      - "3000:3000"
    environment:
      NODE_ENV: development
      PORT: 3000
      DATABASE_URL: postgresql://postgres:postgres@postgres:5432/questionnaire?schema=public
      REDIS_HOST: redis
      REDIS_PORT: 6379
      JWT_SECRET: dev-jwt-secret-change-in-production
      JWT_REFRESH_SECRET: dev-refresh-secret-change-in-production
    volumes:
      - .:/app
      - /app/node_modules
    depends_on:
      postgres:
        condition: service_healthy
      redis:
        condition: service_healthy
    networks:
      - questionnaire-network

volumes:
  postgres_data:
  redis_data:


networks:
  questionnaire-network:
    driver: bridge
    ipam:
      config:
        - subnet: 172.28.0.0/16

```

## c:\Users\avi\OneDrive - BAS & More\Qoder Repo\Quiz-to-build\Quiz-to-build\scripts\docker-wsl.ps1
```
# Docker WSL Workaround Script
# Use this when Docker Desktop's Windows integration is not working
# Source: Docker Desktop named pipe communication issue

Write-Host "Setting up Docker via WSL workaround..." -ForegroundColor Cyan

# Create functions that route Docker commands through WSL Ubuntu
function global:docker {
    wsl -d Ubuntu -e docker $args
}

function global:docker-compose {
    # Convert Windows paths to WSL paths if needed
    $wslArgs = $args | ForEach-Object {
        if ($_ -match '^[A-Za-z]:') {
            # Convert Windows path to WSL path
            $_ -replace '^([A-Za-z]):', '/mnt/$1'.ToLower() -replace '\\', '/'
        } else {
            $_
        }
    }
    wsl -d Ubuntu -e docker compose $wslArgs
}

# Test the connection
Write-Host "`nTesting Docker connection..." -ForegroundColor Yellow
try {
    $version = wsl -d Ubuntu -e docker version --format '{{.Server.Version}}' 2>&1
    if ($LASTEXITCODE -eq 0) {
        Write-Host "Docker Server: $version" -ForegroundColor Green
        Write-Host "Docker is now accessible via WSL!" -ForegroundColor Green
    } else {
        Write-Host "Docker not responding in WSL" -ForegroundColor Red
    }
} catch {
    Write-Host "Error: $_" -ForegroundColor Red
}

Write-Host "`nUsage:" -ForegroundColor Cyan
Write-Host "  docker ps              - List containers"
Write-Host "  docker-compose up -d   - Start services"
Write-Host "  docker-compose down    - Stop services"

```

## c:\Users\avi\OneDrive - BAS & More\Qoder Repo\Quiz-to-build\Quiz-to-build\.dockerignore
```
node_modules
npm-debug.log
.git
.gitignore
.env
.env.*
!.env.example
dist
coverage
.nyc_output
*.log
.DS_Store
Thumbs.db
.idea
.vscode
*.md
!README.md
docker-compose*.yml
Dockerfile*
.dockerignore

```

## c:\Users\avi\OneDrive - BAS & More\Qoder Repo\Quiz-to-build\Quiz-to-build\libs\shared\src\dto\response.dto.ts
```
import { ApiProperty, ApiPropertyOptional } from '@nestjs/swagger';

export class PaginationMeta {
  @ApiProperty({ example: 1 })
  page!: number;

  @ApiProperty({ example: 20 })
  limit!: number;

  @ApiProperty({ example: 100 })
  totalItems!: number;

  @ApiProperty({ example: 5 })
  totalPages!: number;
}

export class ApiResponseDto<T> {
  @ApiProperty({ example: true })
  success!: boolean;

  @ApiProperty()
  data!: T;

  @ApiPropertyOptional()
  meta?: {
    timestamp: string;
    requestId?: string;
  };
}

export class PaginatedResponseDto<T> {
  @ApiProperty({ example: true })
  success!: boolean;

  @ApiProperty()
  data!: {
    items: T[];
    pagination: PaginationMeta;
  };
}

export class ErrorResponseDto {
  @ApiProperty({ example: false })
  success!: false;

  @ApiProperty({
    example: {
      code: 'NOT_FOUND',
      message: 'Resource not found',
      timestamp: '2025-01-15T10:00:00.000Z',
    },
  })
  error!: {
    code: string;
    message: string;
    details?: unknown[];
    requestId?: string;
    timestamp: string;
  };
}

```

## c:\Users\avi\OneDrive - BAS & More\Qoder Repo\Quiz-to-build\Quiz-to-build\apps\api\tsconfig.json
```
{
  "extends": "../../tsconfig.json",
  "compilerOptions": {
    "outDir": "./dist",
    "baseUrl": ".",
    "paths": {
      "@libs/database": [
        "../../libs/database/src"
      ],
      "@libs/database/*": [
        "../../libs/database/src/*"
      ],
      "@libs/redis": [
        "../../libs/redis/src"
      ],
      "@libs/redis/*": [
        "../../libs/redis/src/*"
      ],
      "@libs/shared": [
        "../../libs/shared/src"
      ],
      "@libs/shared/*": [
        "../../libs/shared/src/*"
      ]
    },
    "skipLibCheck": true
  },
  "include": [
    "src/**/*"
  ],
  "exclude": [
    "node_modules",
    "dist",
    "**/*.spec.ts",
    "test/**/*"
  ]
}
```

## c:\Users\avi\OneDrive - BAS & More\Qoder Repo\Quiz-to-build\Quiz-to-build\tsconfig.json
```
{
  "compilerOptions": {
    "target": "ES2022",
    "module": "commonjs",
    "lib": [
      "ES2022"
    ],
    "moduleResolution": "node",
    "strict": true,
    "strictNullChecks": true,
    "strictPropertyInitialization": false,
    "noImplicitAny": true,
    "noImplicitReturns": true,
    "noImplicitThis": true,
    "noUnusedLocals": false,
    "noUnusedParameters": false,
    "noFallthroughCasesInSwitch": true,
    "esModuleInterop": true,
    "skipLibCheck": true,
    "forceConsistentCasingInFileNames": true,
    "declaration": true,
    "declarationMap": true,
    "sourceMap": true,
    "outDir": "./dist",
    "baseUrl": ".",
    "paths": {
      "@app/*": [
        "apps/api/src/*"
      ],
      "@libs/database": [
        "libs/database/src"
      ],
      "@libs/database/*": [
        "libs/database/src/*"
      ],
      "@libs/redis": [
        "libs/redis/src"
      ],
      "@libs/redis/*": [
        "libs/redis/src/*"
      ],
      "@libs/shared": [
        "libs/shared/src"
      ],
      "@libs/shared/*": [
        "libs/shared/src/*"
      ]
    },
    "emitDecoratorMetadata": true,
    "experimentalDecorators": true,
    "resolveJsonModule": true
  },
  "exclude": [
    "node_modules",
    "dist",
    "coverage"
  ]
}
```

## c:\Users\avi\OneDrive - BAS & More\Qoder Repo\Quiz-to-build\Quiz-to-build\apps\api\src\modules\standards\standards.service.ts
```
import { Injectable, NotFoundException } from '@nestjs/common';
import { PrismaService } from '@libs/database';
import { StandardCategory, EngineeringStandard } from '@prisma/client';
import {
  StandardResponse,
  StandardWithMappings,
  GeneratedStandardsSection,
  Principle,
  STANDARD_CATEGORY_TITLES,
} from './types/standard.types';

@Injectable()
export class StandardsService {
  constructor(private readonly prisma: PrismaService) { }

  async findAll(): Promise<StandardResponse[]> {
    const standards = await this.prisma.engineeringStandard.findMany({
      where: { isActive: true },
      orderBy: { category: 'asc' },
    });

    return standards.map((standard) => this.mapToResponse(standard));
  }

  async findByCategory(category: StandardCategory): Promise<StandardResponse> {
    const standard = await this.prisma.engineeringStandard.findUnique({
      where: { category },
    });

    if (!standard) {
      throw new NotFoundException(`Standard category ${category} not found`);
    }

    return this.mapToResponse(standard);
  }

  async findWithMappings(category: StandardCategory): Promise<StandardWithMappings> {
    const standard = await this.prisma.engineeringStandard.findUnique({
      where: { category },
      include: {
        documentMappings: {
          include: {
            documentType: {
              select: {
                id: true,
                name: true,
                slug: true,
              },
            },
          },
          orderBy: { priority: 'asc' },
        },
      },
    });

    if (!standard) {
      throw new NotFoundException(`Standard category ${category} not found`);
    }

    return {
      ...this.mapToResponse(standard),
      documentTypes: standard.documentMappings.map((mapping) => ({
        id: mapping.documentType.id,
        name: mapping.documentType.name,
        slug: mapping.documentType.slug,
        sectionTitle: mapping.sectionTitle ?? undefined,
        priority: mapping.priority,
      })),
    };
  }

  async getStandardsForDocument(documentTypeIdOrSlug: string): Promise<StandardResponse[]> {
    // Try to find by ID first, then by slug
    const documentType = await this.prisma.documentType.findFirst({
      where: {
        OR: [
          { id: documentTypeIdOrSlug },
          { slug: documentTypeIdOrSlug },
        ],
      },
      include: {
        standardMappings: {
          where: {
            standard: {
              isActive: true,
            },
          },
          include: {
            standard: true,
          },
          orderBy: { priority: 'asc' },
        },
      },
    });

    if (!documentType) {
      throw new NotFoundException(`Document type ${documentTypeIdOrSlug} not found`);
    }

    return documentType.standardMappings.map((mapping) =>
      this.mapToResponse(mapping.standard),
    );
  }

  async generateStandardsSection(documentTypeIdOrSlug: string): Promise<GeneratedStandardsSection> {
    const documentType = await this.prisma.documentType.findFirst({
      where: {
        OR: [
          { id: documentTypeIdOrSlug },
          { slug: documentTypeIdOrSlug },
        ],
      },
      include: {
        standardMappings: {
          where: {
            standard: {
              isActive: true,
            },
          },
          include: {
            standard: true,
          },
          orderBy: { priority: 'asc' },
        },
      },
    });

    if (!documentType) {
      throw new NotFoundException(`Document type ${documentTypeIdOrSlug} not found`);
    }

    if (documentType.standardMappings.length === 0) {
      return {
        markdown: '',
        standards: [],
      };
    }

    const standards = documentType.standardMappings.map((mapping) => ({
      category: mapping.standard.category,
      title: mapping.sectionTitle || STANDARD_CATEGORY_TITLES[mapping.standard.category],
      principles: mapping.standard.principles as unknown as Principle[],
    }));

    const markdown = this.generateMarkdown(standards);

    return {
      markdown,
      standards,
    };
  }

  private generateMarkdown(
    standards: { category: StandardCategory; title: string; principles: Principle[] }[],
  ): string {
    if (standards.length === 0) {
      return '';
    }

    const lines: string[] = [
      '## Engineering Standards Applied',
      '',
      'This document adheres to the following engineering standards and best practices:',
      '',
    ];

    for (const standard of standards) {
      lines.push(`### ${standard.title}`);
      lines.push('');

      for (const principle of standard.principles) {
        lines.push(`- **${principle.title}**: ${principle.description}`);
      }

      lines.push('');
    }

    lines.push('---');
    lines.push('');
    lines.push('*Standards Version: 2026*');

    return lines.join('\n');
  }

  private mapToResponse(standard: EngineeringStandard): StandardResponse {
    return {
      id: standard.id,
      category: standard.category,
      title: standard.title,
      description: standard.description,
      principles: standard.principles as unknown as Principle[],
      version: standard.version,
      isActive: standard.isActive,
    };
  }
}

```

## c:\Users\avi\OneDrive - BAS & More\Qoder Repo\Quiz-to-build\Quiz-to-build\apps\api\src\modules\standards\standards.service.spec.ts
```
import { Test, TestingModule } from '@nestjs/testing';
import { NotFoundException } from '@nestjs/common';
import { StandardsService } from './standards.service';
import { PrismaService } from '@libs/database';
import { StandardCategory } from '@prisma/client';

describe('StandardsService', () => {
  let service: StandardsService;
  let prismaService: any;

  const mockStandard = {
    id: 'standard-1',
    category: 'MODERN_ARCHITECTURE' as StandardCategory,
    title: 'Modern Architecture & Design',
    description: 'Architectural principles for building scalable systems.',
    principles: [
      {
        title: 'Modular Monoliths',
        description: 'Favor right-sized services determined by business boundaries.',
      },
      {
        title: 'Cloud-Native Foundations',
        description: 'Use IaC and containers for reproducible environments.',
      },
    ],
    version: '2026',
    isActive: true,
    createdAt: new Date(),
    updatedAt: new Date(),
  };

  const mockDocumentType = {
    id: 'doc-type-1',
    name: 'Product Architecture',
    slug: 'product-architecture',
    category: 'CTO',
    standardMappings: [
      {
        id: 'mapping-1',
        documentTypeId: 'doc-type-1',
        standardId: 'standard-1',
        priority: 0,
        sectionTitle: null,
        standard: mockStandard,
      },
    ],
  };

  beforeEach(async () => {
    const mockPrismaService = {
      engineeringStandard: {
        findMany: jest.fn(),
        findUnique: jest.fn(),
      },
      documentType: {
        findFirst: jest.fn(),
      },
    };

    const module: TestingModule = await Test.createTestingModule({
      providers: [
        StandardsService,
        { provide: PrismaService, useValue: mockPrismaService },
      ],
    }).compile();

    service = module.get<StandardsService>(StandardsService);
    prismaService = module.get(PrismaService);
  });

  afterEach(() => {
    jest.clearAllMocks();
  });

  describe('findAll', () => {
    it('should return all active standards', async () => {
      prismaService.engineeringStandard.findMany.mockResolvedValue([mockStandard]);

      const result = await service.findAll();

      expect(result).toHaveLength(1);
      expect(result[0].category).toBe('MODERN_ARCHITECTURE');
      expect(prismaService.engineeringStandard.findMany).toHaveBeenCalledWith({
        where: { isActive: true },
        orderBy: { category: 'asc' },
      });
    });

    it('should return empty array when no standards exist', async () => {
      prismaService.engineeringStandard.findMany.mockResolvedValue([]);

      const result = await service.findAll();

      expect(result).toHaveLength(0);
    });
  });

  describe('findByCategory', () => {
    it('should return standard for valid category', async () => {
      prismaService.engineeringStandard.findUnique.mockResolvedValue(mockStandard);

      const result = await service.findByCategory('MODERN_ARCHITECTURE' as StandardCategory);

      expect(result.id).toBe('standard-1');
      expect(result.title).toBe('Modern Architecture & Design');
      expect(result.principles).toHaveLength(2);
    });

    it('should throw NotFoundException for invalid category', async () => {
      prismaService.engineeringStandard.findUnique.mockResolvedValue(null);

      await expect(
        service.findByCategory('INVALID_CATEGORY' as StandardCategory),
      ).rejects.toThrow(NotFoundException);
    });
  });

  describe('findWithMappings', () => {
    it('should return standard with document type mappings', async () => {
      const standardWithMappings = {
        ...mockStandard,
        documentMappings: [
          {
            id: 'mapping-1',
            priority: 0,
            sectionTitle: 'Architecture Standards',
            documentType: {
              id: 'doc-type-1',
              name: 'Product Architecture',
              slug: 'product-architecture',
            },
          },
        ],
      };
      prismaService.engineeringStandard.findUnique.mockResolvedValue(
        standardWithMappings as any,
      );

      const result = await service.findWithMappings('MODERN_ARCHITECTURE' as StandardCategory);

      expect(result.documentTypes).toHaveLength(1);
      expect(result.documentTypes[0].slug).toBe('product-architecture');
      expect(result.documentTypes[0].sectionTitle).toBe('Architecture Standards');
    });

    it('should handle null sectionTitle', async () => {
      const standardWithMappings = {
        ...mockStandard,
        documentMappings: [
          {
            id: 'mapping-1',
            priority: 0,
            sectionTitle: null,
            documentType: {
              id: 'doc-type-1',
              name: 'Product Architecture',
              slug: 'product-architecture',
            },
          },
        ],
      };
      prismaService.engineeringStandard.findUnique.mockResolvedValue(
        standardWithMappings as any,
      );

      const result = await service.findWithMappings('MODERN_ARCHITECTURE' as StandardCategory);

      expect(result.documentTypes[0].sectionTitle).toBeUndefined();
    });
  });

  describe('getStandardsForDocument', () => {
    it('should return standards mapped to document type by ID', async () => {
      prismaService.documentType.findFirst.mockResolvedValue(mockDocumentType as any);

      const result = await service.getStandardsForDocument('doc-type-1');

      expect(result).toHaveLength(1);
      expect(result[0].category).toBe('MODERN_ARCHITECTURE');
    });

    it('should return standards mapped to document type by slug', async () => {
      prismaService.documentType.findFirst.mockResolvedValue(mockDocumentType as any);

      const result = await service.getStandardsForDocument('product-architecture');

      expect(result).toHaveLength(1);
      expect(prismaService.documentType.findFirst).toHaveBeenCalledWith(
        expect.objectContaining({
          where: {
            OR: [
              { id: 'product-architecture' },
              { slug: 'product-architecture' },
            ],
          },
        }),
      );
    });

    it('should throw NotFoundException for invalid document type', async () => {
      prismaService.documentType.findFirst.mockResolvedValue(null);

      await expect(
        service.getStandardsForDocument('non-existent'),
      ).rejects.toThrow(NotFoundException);
    });

    it('should return empty array when document has no standards', async () => {
      const docTypeNoStandards = {
        ...mockDocumentType,
        standardMappings: [],
      };
      prismaService.documentType.findFirst.mockResolvedValue(docTypeNoStandards as any);

      const result = await service.getStandardsForDocument('doc-type-1');

      expect(result).toHaveLength(0);
    });
  });

  describe('generateStandardsSection', () => {
    it('should generate markdown section for document type', async () => {
      prismaService.documentType.findFirst.mockResolvedValue(mockDocumentType as any);

      const result = await service.generateStandardsSection('product-architecture');

      expect(result.markdown).toContain('## Engineering Standards Applied');
      expect(result.markdown).toContain('Modern Architecture & Design');
      expect(result.markdown).toContain('**Modular Monoliths**');
      expect(result.standards).toHaveLength(1);
    });

    it('should return empty markdown when no standards are mapped', async () => {
      const docTypeNoStandards = {
        ...mockDocumentType,
        standardMappings: [],
      };
      prismaService.documentType.findFirst.mockResolvedValue(docTypeNoStandards as any);

      const result = await service.generateStandardsSection('doc-type-1');

      expect(result.markdown).toBe('');
      expect(result.standards).toHaveLength(0);
    });

    it('should use custom section title when provided', async () => {
      const docTypeWithCustomTitle = {
        ...mockDocumentType,
        standardMappings: [
          {
            ...mockDocumentType.standardMappings[0],
            sectionTitle: 'Custom Architecture Guidelines',
          },
        ],
      };
      prismaService.documentType.findFirst.mockResolvedValue(docTypeWithCustomTitle as any);

      const result = await service.generateStandardsSection('doc-type-1');

      expect(result.markdown).toContain('Custom Architecture Guidelines');
      expect(result.standards[0].title).toBe('Custom Architecture Guidelines');
    });

    it('should throw NotFoundException for invalid document type', async () => {
      prismaService.documentType.findFirst.mockResolvedValue(null);

      await expect(
        service.generateStandardsSection('non-existent'),
      ).rejects.toThrow(NotFoundException);
    });

    it('should include version in markdown output', async () => {
      prismaService.documentType.findFirst.mockResolvedValue(mockDocumentType as any);

      const result = await service.generateStandardsSection('product-architecture');

      expect(result.markdown).toContain('Standards Version: 2026');
    });

    it('should format multiple principles correctly', async () => {
      prismaService.documentType.findFirst.mockResolvedValue(mockDocumentType as any);

      const result = await service.generateStandardsSection('product-architecture');

      // Check both principles are included
      expect(result.markdown).toContain('Modular Monoliths');
      expect(result.markdown).toContain('Cloud-Native Foundations');
    });
  });

  describe('mapToResponse', () => {
    it('should correctly map standard entity to response', async () => {
      prismaService.engineeringStandard.findUnique.mockResolvedValue(mockStandard);

      const result = await service.findByCategory('MODERN_ARCHITECTURE' as StandardCategory);

      expect(result).toEqual({
        id: 'standard-1',
        category: 'MODERN_ARCHITECTURE',
        title: 'Modern Architecture & Design',
        description: 'Architectural principles for building scalable systems.',
        principles: [
          {
            title: 'Modular Monoliths',
            description: 'Favor right-sized services determined by business boundaries.',
          },
          {
            title: 'Cloud-Native Foundations',
            description: 'Use IaC and containers for reproducible environments.',
          },
        ],
        version: '2026',
        isActive: true,
      });
    });
  });
});

```

## c:\Users\avi\OneDrive - BAS & More\Qoder Repo\Quiz-to-build\Quiz-to-build\apps\api\src\modules\standards\dto\standard.dto.ts
```
import { ApiProperty, ApiPropertyOptional } from '@nestjs/swagger';
import { IsEnum, IsString } from 'class-validator';
import { StandardCategory } from '@prisma/client';

export class StandardResponseDto {
  @ApiProperty({ description: 'Standard ID' })
  id: string;

  @ApiProperty({ enum: StandardCategory, description: 'Standard category' })
  category: StandardCategory;

  @ApiProperty({ description: 'Standard title' })
  title: string;

  @ApiProperty({ description: 'Standard description' })
  description: string;

  @ApiProperty({ description: 'List of principles', type: 'array' })
  principles: {
    title: string;
    description: string;
    examples?: string[];
  }[];

  @ApiProperty({ description: 'Standard version' })
  version: string;

  @ApiProperty({ description: 'Whether the standard is active' })
  isActive: boolean;
}

export class StandardCategoryParamDto {
  @ApiProperty({ enum: StandardCategory, description: 'Standard category' })
  @IsEnum(StandardCategory)
  category: StandardCategory;
}

export class DocumentStandardsParamDto {
  @ApiProperty({ description: 'Document type ID or slug' })
  @IsString()
  documentTypeId: string;
}

export class StandardsSectionResponseDto {
  @ApiProperty({ description: 'Generated Markdown content' })
  markdown: string;

  @ApiProperty({ description: 'Standards included in the section', type: 'array' })
  standards: {
    category: StandardCategory;
    title: string;
    principles: {
      title: string;
      description: string;
    }[];
  }[];
}

export class DocumentTypeMappingDto {
  @ApiProperty({ description: 'Document type ID' })
  id: string;

  @ApiProperty({ description: 'Document type name' })
  name: string;

  @ApiProperty({ description: 'Document type slug' })
  slug: string;

  @ApiPropertyOptional({ description: 'Custom section title for this document' })
  sectionTitle?: string;

  @ApiProperty({ description: 'Priority order in the document' })
  priority: number;
}

export class StandardWithMappingsDto extends StandardResponseDto {
  @ApiProperty({ description: 'Document types this standard is mapped to', type: [DocumentTypeMappingDto] })
  documentTypes: DocumentTypeMappingDto[];
}

```

## c:\Users\avi\OneDrive - BAS & More\Qoder Repo\Quiz-to-build\Quiz-to-build\apps\api\src\modules\session\session.service.ts
```
import {
  Injectable,
  NotFoundException,
  BadRequestException,
  ForbiddenException,
  Inject,
  forwardRef,
} from '@nestjs/common';
import { PrismaService } from '@libs/database';
import { Session, SessionStatus, Question, Prisma } from '@prisma/client';
import { CreateSessionDto } from './dto/create-session.dto';
import { SubmitResponseDto } from './dto/submit-response.dto';
import { QuestionnaireService, QuestionResponse } from '../questionnaire/questionnaire.service';
import { AdaptiveLogicService } from '../adaptive-logic/adaptive-logic.service';
import { PaginationDto } from '@libs/shared';

export interface ProgressInfo {
  percentage: number;
  answeredQuestions: number;
  totalQuestions: number;
  estimatedTimeRemaining?: number;
}

export interface SessionResponse {
  id: string;
  questionnaireId: string;
  userId: string;
  status: SessionStatus;
  industry?: string;
  progress: ProgressInfo;
  currentSection?: {
    id: string;
    name: string;
  };
  createdAt: Date;
  lastActivityAt: Date;
}

export interface NextQuestionResponse {
  questions: QuestionResponse[];
  section: {
    id: string;
    name: string;
    progress: number;
  };
  overallProgress: ProgressInfo;
}

export interface SubmitResponseResult {
  responseId: string;
  questionId: string;
  value: unknown;
  validationResult: {
    isValid: boolean;
    errors?: string[];
  };
  adaptiveChanges?: {
    questionsAdded: string[];
    questionsRemoved: string[];
    newEstimatedTotal: number;
  };
  progress: ProgressInfo;
  createdAt: Date;
}

export interface ContinueSessionResponse {
  session: SessionResponse;
  nextQuestions: QuestionResponse[];
  currentSection: {
    id: string;
    name: string;
    description?: string;
    progress: number;
    questionsInSection: number;
    answeredInSection: number;
  };
  overallProgress: ProgressInfo;
  adaptiveState: {
    visibleQuestionCount: number;
    skippedQuestionCount: number;
    appliedRules: string[];
  };
  isComplete: boolean;
  canComplete: boolean;
}

@Injectable()
export class SessionService {
  constructor(
    private readonly prisma: PrismaService,
    private readonly questionnaireService: QuestionnaireService,
    @Inject(forwardRef(() => AdaptiveLogicService))
    private readonly adaptiveLogicService: AdaptiveLogicService,
  ) { }

  async create(userId: string, dto: CreateSessionDto): Promise<SessionResponse> {
    // Get questionnaire
    const questionnaire = await this.questionnaireService.findById(dto.questionnaireId);

    // Get total question count
    const totalQuestions = await this.questionnaireService.getTotalQuestionCount(
      dto.questionnaireId,
    );

    // Get first section and question
    const firstSection = questionnaire.sections[0];
    const firstQuestion = firstSection?.questions?.[0];

    // Create session
    const session = await this.prisma.session.create({
      data: {
        userId,
        questionnaireId: dto.questionnaireId,
        questionnaireVersion: questionnaire.version,
        industry: dto.industry,
        status: SessionStatus.IN_PROGRESS,
        progress: {
          percentage: 0,
          answered: 0,
          total: totalQuestions,
        },
        currentSectionId: firstSection?.id,
        currentQuestionId: firstQuestion?.id,
        adaptiveState: {
          activeQuestionIds: [],
          skippedQuestionIds: [],
          branchHistory: [],
        },
      },
      include: {
        currentSection: true,
      },
    });

    return this.mapToSessionResponse(session, totalQuestions);
  }

  async findById(sessionId: string, userId: string): Promise<SessionResponse> {
    const session = await this.prisma.session.findUnique({
      where: { id: sessionId },
      include: {
        currentSection: true,
        questionnaire: true,
      },
    });

    if (!session) {
      throw new NotFoundException('Session not found');
    }

    if (session.userId !== userId) {
      throw new ForbiddenException('Access denied to this session');
    }

    const totalQuestions = await this.questionnaireService.getTotalQuestionCount(
      session.questionnaireId,
    );

    return this.mapToSessionResponse(session, totalQuestions);
  }

  async findAllByUser(
    userId: string,
    pagination: PaginationDto,
    status?: SessionStatus,
  ): Promise<{ items: SessionResponse[]; total: number }> {
    const where = {
      userId,
      ...(status && { status }),
    };

    const [sessions, total] = await Promise.all([
      this.prisma.session.findMany({
        where,
        skip: pagination.skip,
        take: pagination.limit,
        orderBy: { startedAt: 'desc' },
        include: {
          currentSection: true,
          questionnaire: true,
        },
      }),
      this.prisma.session.count({ where }),
    ]);

    const items = await Promise.all(
      sessions.map(async (session) => {
        const totalQuestions = await this.questionnaireService.getTotalQuestionCount(
          session.questionnaireId,
        );
        return this.mapToSessionResponse(session, totalQuestions);
      }),
    );

    return { items, total };
  }

  async getNextQuestion(
    sessionId: string,
    userId: string,
    count: number = 1,
  ): Promise<NextQuestionResponse> {
    const session = await this.getSessionWithValidation(sessionId, userId);

    if (session.status === SessionStatus.COMPLETED) {
      throw new BadRequestException('Session is already completed');
    }

    // Get all responses for this session
    const responses = await this.prisma.response.findMany({
      where: { sessionId },
    });

    const responseMap = new Map(responses.map((r) => [r.questionId, r.value]));

    // Get current question and evaluate visibility
    const currentQuestion = await this.questionnaireService.getQuestionById(
      session.currentQuestionId!,
    );

    if (!currentQuestion) {
      throw new NotFoundException('Current question not found');
    }

    // Evaluate adaptive logic to get visible questions
    const visibleQuestions = await this.adaptiveLogicService.getVisibleQuestions(
      session.questionnaireId,
      responseMap,
    );

    // Get the next N visible questions starting from current position
    const nextQuestions: QuestionResponse[] = [];
    let currentIndex = visibleQuestions.findIndex((q) => q.id === session.currentQuestionId);

    for (let i = currentIndex; i < visibleQuestions.length && nextQuestions.length < count; i++) {
      const question = visibleQuestions[i];
      // Skip already answered questions
      if (!responseMap.has(question.id)) {
        nextQuestions.push(this.mapQuestionToResponse(question));
      }
    }

    // Calculate progress
    const answeredCount = responses.length;
    const totalVisible = visibleQuestions.length;
    const progress = this.calculateProgress(answeredCount, totalVisible);

    // Get section info
    const section = await this.prisma.section.findUnique({
      where: { id: currentQuestion.sectionId },
    });

    const sectionQuestions = visibleQuestions.filter(
      (q) => q.sectionId === currentQuestion.sectionId,
    );
    const sectionAnswered = sectionQuestions.filter((q) => responseMap.has(q.id)).length;
    const sectionProgress = Math.round((sectionAnswered / sectionQuestions.length) * 100);

    return {
      questions: nextQuestions,
      section: {
        id: section!.id,
        name: section!.name,
        progress: sectionProgress,
      },
      overallProgress: progress,
    };
  }

  async submitResponse(
    sessionId: string,
    userId: string,
    dto: SubmitResponseDto,
  ): Promise<SubmitResponseResult> {
    const session = await this.getSessionWithValidation(sessionId, userId);

    if (session.status === SessionStatus.COMPLETED) {
      throw new BadRequestException('Session is already completed');
    }

    // Validate question exists
    const question = await this.questionnaireService.getQuestionById(dto.questionId);
    if (!question) {
      throw new NotFoundException('Question not found');
    }

    // Validate response value
    const validation = this.validateResponse(question, dto.value);

    // Upsert response
    const response = await this.prisma.response.upsert({
      where: {
        sessionId_questionId: {
          sessionId,
          questionId: dto.questionId,
        },
      },
      create: {
        sessionId,
        questionId: dto.questionId,
        value: dto.value as Prisma.InputJsonValue,
        isValid: validation.isValid,
        validationErrors: validation.errors ? { errors: validation.errors } : Prisma.JsonNull,
        timeSpentSeconds: dto.timeSpentSeconds,
      },
      update: {
        value: dto.value as Prisma.InputJsonValue,
        isValid: validation.isValid,
        validationErrors: validation.errors ? { errors: validation.errors } : Prisma.JsonNull,
        timeSpentSeconds: dto.timeSpentSeconds,
        revision: { increment: 1 },
      },
    });

    // Get all responses to evaluate adaptive logic
    const allResponses = await this.prisma.response.findMany({
      where: { sessionId },
    });
    const responseMap = new Map(allResponses.map((r) => [r.questionId, r.value]));

    // Evaluate adaptive changes
    const visibleQuestions = await this.adaptiveLogicService.getVisibleQuestions(
      session.questionnaireId,
      responseMap,
    );

    // Find next question
    const nextQuestion = this.findNextUnansweredQuestion(
      visibleQuestions,
      dto.questionId,
      responseMap,
    );

    // Update session
    const progress = this.calculateProgress(allResponses.length, visibleQuestions.length);

    await this.prisma.session.update({
      where: { id: sessionId },
      data: {
        currentQuestionId: nextQuestion?.id,
        currentSectionId: nextQuestion?.sectionId,
        lastActivityAt: new Date(),
        progress: {
          percentage: progress.percentage,
          answered: progress.answeredQuestions,
          total: progress.totalQuestions,
        },
      },
    });

    return {
      responseId: response.id,
      questionId: dto.questionId,
      value: dto.value,
      validationResult: validation,
      progress,
      createdAt: response.answeredAt,
    };
  }

  async completeSession(sessionId: string, userId: string): Promise<SessionResponse> {
    const session = await this.getSessionWithValidation(sessionId, userId);

    if (session.status === SessionStatus.COMPLETED) {
      throw new BadRequestException('Session is already completed');
    }

    // Update session status
    const updatedSession = await this.prisma.session.update({
      where: { id: sessionId },
      data: {
        status: SessionStatus.COMPLETED,
        completedAt: new Date(),
      },
      include: {
        currentSection: true,
        questionnaire: true,
      },
    });

    const totalQuestions = await this.questionnaireService.getTotalQuestionCount(
      session.questionnaireId,
    );

    return this.mapToSessionResponse(updatedSession, totalQuestions);
  }

  async continueSession(
    sessionId: string,
    userId: string,
    questionCount: number = 1,
  ): Promise<ContinueSessionResponse> {
    // Get session with full context
    const session = await this.prisma.session.findUnique({
      where: { id: sessionId },
      include: {
        currentSection: true,
        questionnaire: {
          include: {
            sections: {
              orderBy: { orderIndex: 'asc' },
            },
          },
        },
      },
    });

    if (!session) {
      throw new NotFoundException('Session not found');
    }

    if (session.userId !== userId) {
      throw new ForbiddenException('Access denied to this session');
    }

    // Check if already completed
    const isComplete = session.status === SessionStatus.COMPLETED;

    // Get all responses for this session
    const responses = await this.prisma.response.findMany({
      where: { sessionId },
      orderBy: { answeredAt: 'desc' },
    });

    const responseMap = new Map(responses.map((r) => [r.questionId, r.value]));

    // Evaluate adaptive logic to get visible questions
    const visibleQuestions = await this.adaptiveLogicService.getVisibleQuestions(
      session.questionnaireId,
      responseMap,
    );

    // Get adaptive state info
    const adaptiveState = session.adaptiveState as {
      skippedQuestionIds?: string[];
      branchHistory?: string[];
    };

    // Calculate total questions and skipped
    const totalQuestionsInQuestionnaire = await this.questionnaireService.getTotalQuestionCount(
      session.questionnaireId,
    );
    const skippedCount = totalQuestionsInQuestionnaire - visibleQuestions.length;

    // Find next unanswered questions
    const nextQuestions: QuestionResponse[] = [];

    if (!isComplete && session.currentQuestionId) {
      const currentIndex = visibleQuestions.findIndex(
        (q) => q.id === session.currentQuestionId,
      );

      // Start from current question and find unanswered ones
      for (let i = Math.max(0, currentIndex); i < visibleQuestions.length && nextQuestions.length < questionCount; i++) {
        const question = visibleQuestions[i];
        if (!responseMap.has(question.id)) {
          nextQuestions.push(this.mapQuestionToResponse(question));
        }
      }

      // If we didn't find enough, check from the beginning
      if (nextQuestions.length < questionCount) {
        for (let i = 0; i < currentIndex && nextQuestions.length < questionCount; i++) {
          const question = visibleQuestions[i];
          if (!responseMap.has(question.id)) {
            nextQuestions.push(this.mapQuestionToResponse(question));
          }
        }
      }
    }

    // Calculate progress
    const answeredCount = responses.length;
    const progress = this.calculateProgress(answeredCount, visibleQuestions.length);

    // Get current section details
    let currentSectionInfo = {
      id: '',
      name: '',
      description: undefined as string | undefined,
      progress: 0,
      questionsInSection: 0,
      answeredInSection: 0,
    };

    if (session.currentSection) {
      const sectionQuestions = visibleQuestions.filter(
        (q) => q.sectionId === session.currentSection!.id,
      );
      const sectionAnswered = sectionQuestions.filter((q) => responseMap.has(q.id)).length;

      currentSectionInfo = {
        id: session.currentSection.id,
        name: session.currentSection.name,
        description: (session.currentSection as any).description ?? undefined,
        progress: sectionQuestions.length > 0
          ? Math.round((sectionAnswered / sectionQuestions.length) * 100)
          : 0,
        questionsInSection: sectionQuestions.length,
        answeredInSection: sectionAnswered,
      };
    }

    // Determine if session can be completed (all required questions answered)
    const unansweredRequired = visibleQuestions.filter(
      (q) => q.isRequired && !responseMap.has(q.id),
    );
    const canComplete = unansweredRequired.length === 0 && answeredCount > 0;

    // Build session response
    const sessionResponse: SessionResponse = {
      id: session.id,
      questionnaireId: session.questionnaireId,
      userId: session.userId,
      status: session.status,
      industry: session.industry ?? undefined,
      progress,
      currentSection: session.currentSection
        ? { id: session.currentSection.id, name: session.currentSection.name }
        : undefined,
      createdAt: session.startedAt,
      lastActivityAt: session.lastActivityAt,
    };

    // Update last activity timestamp
    if (!isComplete) {
      await this.prisma.session.update({
        where: { id: sessionId },
        data: { lastActivityAt: new Date() },
      });
    }

    return {
      session: sessionResponse,
      nextQuestions,
      currentSection: currentSectionInfo,
      overallProgress: progress,
      adaptiveState: {
        visibleQuestionCount: visibleQuestions.length,
        skippedQuestionCount: skippedCount,
        appliedRules: adaptiveState.branchHistory || [],
      },
      isComplete,
      canComplete,
    };
  }

  private async getSessionWithValidation(
    sessionId: string,
    userId: string,
  ): Promise<Session> {
    const session = await this.prisma.session.findUnique({
      where: { id: sessionId },
    });

    if (!session) {
      throw new NotFoundException('Session not found');
    }

    if (session.userId !== userId) {
      throw new ForbiddenException('Access denied to this session');
    }

    return session;
  }

  private mapToSessionResponse(
    session: Session & { currentSection?: { id: string; name: string } | null },
    totalQuestions: number,
  ): SessionResponse {
    const progress = session.progress as { percentage: number; answered: number; total: number };

    return {
      id: session.id,
      questionnaireId: session.questionnaireId,
      userId: session.userId,
      status: session.status,
      industry: session.industry ?? undefined,
      progress: {
        percentage: progress.percentage,
        answeredQuestions: progress.answered,
        totalQuestions: progress.total || totalQuestions,
      },
      currentSection: session.currentSection
        ? { id: session.currentSection.id, name: session.currentSection.name }
        : undefined,
      createdAt: session.startedAt,
      lastActivityAt: session.lastActivityAt,
    };
  }

  private mapQuestionToResponse(question: Question): QuestionResponse {
    const options = question.options as { id: string; label: string; description?: string }[] | null;
    const validation = question.validationRules as Record<string, unknown> | null;

    return {
      id: question.id,
      text: question.text,
      type: question.type,
      required: question.isRequired,
      helpText: question.helpText ?? undefined,
      explanation: question.explanation ?? undefined,
      placeholder: question.placeholder ?? undefined,
      options: options ?? undefined,
      validation: validation ?? undefined,
    };
  }

  private calculateProgress(answered: number, total: number): ProgressInfo {
    const percentage = total > 0 ? Math.round((answered / total) * 100) : 0;
    const avgTimePerQuestion = 1.5; // minutes
    const estimatedTimeRemaining = Math.ceil((total - answered) * avgTimePerQuestion);

    return {
      percentage,
      answeredQuestions: answered,
      totalQuestions: total,
      estimatedTimeRemaining,
    };
  }

  private validateResponse(
    question: Question,
    value: unknown,
  ): { isValid: boolean; errors?: string[] } {
    const errors: string[] = [];
    const validation = question.validationRules as Record<string, unknown> | null;

    // Check required
    if (question.isRequired && (value === null || value === undefined || value === '')) {
      errors.push('This field is required');
    }

    // Type-specific validation
    if (value !== null && value !== undefined) {
      if (validation) {
        // Min/max length for text
        if (validation.minLength && typeof value === 'string' && value.length < (validation.minLength as number)) {
          errors.push(`Minimum length is ${validation.minLength} characters`);
        }
        if (validation.maxLength && typeof value === 'string' && value.length > (validation.maxLength as number)) {
          errors.push(`Maximum length is ${validation.maxLength} characters`);
        }

        // Min/max for numbers
        if (validation.min && typeof value === 'number' && value < (validation.min as number)) {
          errors.push(`Minimum value is ${validation.min}`);
        }
        if (validation.max && typeof value === 'number' && value > (validation.max as number)) {
          errors.push(`Maximum value is ${validation.max}`);
        }
      }
    }

    return {
      isValid: errors.length === 0,
      errors: errors.length > 0 ? errors : undefined,
    };
  }

  private findNextUnansweredQuestion(
    visibleQuestions: Question[],
    currentQuestionId: string,
    responseMap: Map<string, unknown>,
  ): Question | null {
    const currentIndex = visibleQuestions.findIndex((q) => q.id === currentQuestionId);

    for (let i = currentIndex + 1; i < visibleQuestions.length; i++) {
      if (!responseMap.has(visibleQuestions[i].id)) {
        return visibleQuestions[i];
      }
    }

    // Check if there are any unanswered questions before current
    for (let i = 0; i < currentIndex; i++) {
      if (!responseMap.has(visibleQuestions[i].id)) {
        return visibleQuestions[i];
      }
    }

    return null;
  }
}

```

## c:\Users\avi\OneDrive - BAS & More\Qoder Repo\Quiz-to-build\Quiz-to-build\apps\api\src\modules\session\session.service.spec.ts
```
import { Test, TestingModule } from '@nestjs/testing';
import {
  NotFoundException,
  BadRequestException,
  ForbiddenException,
} from '@nestjs/common';
import { SessionService } from './session.service';
import { PrismaService } from '@libs/database';
import { QuestionnaireService } from '../questionnaire/questionnaire.service';
import { AdaptiveLogicService } from '../adaptive-logic/adaptive-logic.service';
import { SessionStatus, QuestionType } from '@prisma/client';

describe('SessionService', () => {
  let service: SessionService;
  let prismaService: any;
  let questionnaireService: any;
  let adaptiveLogicService: any;

  const mockUserId = 'user-123';
  const mockQuestionnaireId = 'questionnaire-456';
  const mockSessionId = 'session-789';

  const mockQuestionnaire = {
    id: mockQuestionnaireId,
    title: 'Test Questionnaire',
    version: 1,
    sections: [
      {
        id: 'section-1',
        name: 'Section 1',
        questions: [
          { id: 'q1', text: 'Question 1', type: QuestionType.TEXT },
          { id: 'q2', text: 'Question 2', type: QuestionType.SINGLE_CHOICE },
        ],
      },
    ],
  };

  const mockSession = {
    id: mockSessionId,
    userId: mockUserId,
    questionnaireId: mockQuestionnaireId,
    questionnaireVersion: 1,
    status: SessionStatus.IN_PROGRESS,
    industry: 'tech',
    progress: { percentage: 0, answered: 0, total: 10 },
    currentSectionId: 'section-1',
    currentQuestionId: 'q1',
    adaptiveState: {
      activeQuestionIds: [],
      skippedQuestionIds: [],
      branchHistory: [],
    },
    startedAt: new Date(),
    lastActivityAt: new Date(),
    completedAt: null,
    currentSection: { id: 'section-1', name: 'Section 1' },
    questionnaire: mockQuestionnaire,
  };

  const mockQuestion = {
    id: 'q1',
    sectionId: 'section-1',
    text: 'Question 1',
    type: QuestionType.TEXT,
    isRequired: true,
    helpText: null,
    explanation: null,
    placeholder: null,
    options: null,
    validationRules: { minLength: 1, maxLength: 500 },
  };

  beforeEach(async () => {
    const mockPrismaService = {
      session: {
        create: jest.fn(),
        findUnique: jest.fn(),
        findMany: jest.fn(),
        update: jest.fn(),
        count: jest.fn(),
      },
      response: {
        findMany: jest.fn(),
        upsert: jest.fn(),
      },
      section: {
        findUnique: jest.fn(),
      },
    };

    const mockQuestionnaireService = {
      findById: jest.fn(),
      getTotalQuestionCount: jest.fn(),
      getQuestionById: jest.fn(),
    };

    const mockAdaptiveLogicService = {
      getVisibleQuestions: jest.fn(),
    };

    const module: TestingModule = await Test.createTestingModule({
      providers: [
        SessionService,
        { provide: PrismaService, useValue: mockPrismaService },
        { provide: QuestionnaireService, useValue: mockQuestionnaireService },
        { provide: AdaptiveLogicService, useValue: mockAdaptiveLogicService },
      ],
    }).compile();

    service = module.get<SessionService>(SessionService);
    prismaService = module.get(PrismaService);
    questionnaireService = module.get(QuestionnaireService);
    adaptiveLogicService = module.get(AdaptiveLogicService);
  });

  afterEach(() => {
    jest.clearAllMocks();
  });

  describe('create', () => {
    it('should create a new session successfully', async () => {
      questionnaireService.findById.mockResolvedValue(mockQuestionnaire as any);
      questionnaireService.getTotalQuestionCount.mockResolvedValue(10);
      prismaService.session.create.mockResolvedValue(mockSession as any);

      const result = await service.create(mockUserId, {
        questionnaireId: mockQuestionnaireId,
        industry: 'tech',
      });

      expect(result.id).toBe(mockSessionId);
      expect(result.status).toBe(SessionStatus.IN_PROGRESS);
      expect(result.progress.percentage).toBe(0);
      expect(prismaService.session.create).toHaveBeenCalledWith({
        data: expect.objectContaining({
          userId: mockUserId,
          questionnaireId: mockQuestionnaireId,
          status: SessionStatus.IN_PROGRESS,
        }),
        include: { currentSection: true },
      });
    });

    it('should set industry from DTO', async () => {
      questionnaireService.findById.mockResolvedValue(mockQuestionnaire as any);
      questionnaireService.getTotalQuestionCount.mockResolvedValue(10);
      prismaService.session.create.mockResolvedValue(mockSession as any);

      await service.create(mockUserId, {
        questionnaireId: mockQuestionnaireId,
        industry: 'healthcare',
      });

      expect(prismaService.session.create).toHaveBeenCalledWith({
        data: expect.objectContaining({
          industry: 'healthcare',
        }),
        include: expect.any(Object),
      });
    });
  });

  describe('findById', () => {
    it('should return session for valid owner', async () => {
      prismaService.session.findUnique.mockResolvedValue(mockSession as any);
      questionnaireService.getTotalQuestionCount.mockResolvedValue(10);

      const result = await service.findById(mockSessionId, mockUserId);

      expect(result.id).toBe(mockSessionId);
    });

    it('should throw NotFoundException for non-existent session', async () => {
      prismaService.session.findUnique.mockResolvedValue(null);

      await expect(
        service.findById('non-existent', mockUserId),
      ).rejects.toThrow(NotFoundException);
    });

    it('should throw ForbiddenException for unauthorized access', async () => {
      prismaService.session.findUnique.mockResolvedValue(mockSession as any);

      await expect(
        service.findById(mockSessionId, 'different-user'),
      ).rejects.toThrow(ForbiddenException);
    });
  });

  describe('findAllByUser', () => {
    it('should return paginated sessions for user', async () => {
      prismaService.session.findMany.mockResolvedValue([mockSession] as any);
      prismaService.session.count.mockResolvedValue(1);
      questionnaireService.getTotalQuestionCount.mockResolvedValue(10);

      const result = await service.findAllByUser(
        mockUserId,
        { page: 1, limit: 10, skip: 0 },
        undefined,
      );

      expect(result.items).toHaveLength(1);
      expect(result.total).toBe(1);
    });

    it('should filter by status when provided', async () => {
      prismaService.session.findMany.mockResolvedValue([]);
      prismaService.session.count.mockResolvedValue(0);

      await service.findAllByUser(
        mockUserId,
        { page: 1, limit: 10, skip: 0 },
        SessionStatus.COMPLETED,
      );

      expect(prismaService.session.findMany).toHaveBeenCalledWith(
        expect.objectContaining({
          where: { userId: mockUserId, status: SessionStatus.COMPLETED },
        }),
      );
    });
  });

  describe('getNextQuestion', () => {
    beforeEach(() => {
      prismaService.session.findUnique.mockResolvedValue(mockSession as any);
      prismaService.response.findMany.mockResolvedValue([]);
      questionnaireService.getQuestionById.mockResolvedValue(mockQuestion as any);
      adaptiveLogicService.getVisibleQuestions.mockResolvedValue([
        mockQuestion,
        { ...mockQuestion, id: 'q2', text: 'Question 2' },
      ] as any);
      prismaService.section.findUnique.mockResolvedValue({
        id: 'section-1',
        name: 'Section 1',
      } as any);
    });

    it('should return next visible questions', async () => {
      const result = await service.getNextQuestion(mockSessionId, mockUserId);

      expect(result.questions).toHaveLength(1);
      expect(result.section.id).toBe('section-1');
      expect(result.overallProgress.percentage).toBe(0);
    });

    it('should throw BadRequestException for completed session', async () => {
      prismaService.session.findUnique.mockResolvedValue({
        ...mockSession,
        status: SessionStatus.COMPLETED,
      } as any);

      await expect(
        service.getNextQuestion(mockSessionId, mockUserId),
      ).rejects.toThrow(BadRequestException);
    });

    it('should skip already answered questions', async () => {
      prismaService.response.findMany.mockResolvedValue([
        { questionId: 'q1', value: 'answer1' },
      ] as any);

      const result = await service.getNextQuestion(mockSessionId, mockUserId);

      // Should skip q1 since it's answered
      const returnedQuestionIds = result.questions.map((q) => q.id);
      expect(returnedQuestionIds).not.toContain('q1');
    });

    it('should respect count parameter', async () => {
      adaptiveLogicService.getVisibleQuestions.mockResolvedValue([
        { ...mockQuestion, id: 'q1' },
        { ...mockQuestion, id: 'q2' },
        { ...mockQuestion, id: 'q3' },
        { ...mockQuestion, id: 'q4' },
      ] as any);

      const result = await service.getNextQuestion(
        mockSessionId,
        mockUserId,
        3,
      );

      expect(result.questions.length).toBeLessThanOrEqual(3);
    });
  });

  describe('submitResponse', () => {
    const submitDto = {
      questionId: 'q1',
      value: 'Test answer',
      timeSpentSeconds: 30,
    };

    beforeEach(() => {
      prismaService.session.findUnique.mockResolvedValue(mockSession as any);
      questionnaireService.getQuestionById.mockResolvedValue(mockQuestion as any);
      prismaService.response.upsert.mockResolvedValue({
        id: 'response-1',
        sessionId: mockSessionId,
        questionId: 'q1',
        value: 'Test answer',
        isValid: true,
        validationErrors: null,
        answeredAt: new Date(),
        revision: 1,
      } as any);
      prismaService.response.findMany.mockResolvedValue([
        { questionId: 'q1', value: 'Test answer' },
      ] as any);
      adaptiveLogicService.getVisibleQuestions.mockResolvedValue([
        mockQuestion,
        { ...mockQuestion, id: 'q2' },
      ] as any);
      prismaService.session.update.mockResolvedValue(mockSession as any);
    });

    it('should submit response successfully', async () => {
      const result = await service.submitResponse(
        mockSessionId,
        mockUserId,
        submitDto,
      );

      expect(result.responseId).toBe('response-1');
      expect(result.questionId).toBe('q1');
      expect(result.validationResult.isValid).toBe(true);
    });

    it('should throw BadRequestException for completed session', async () => {
      prismaService.session.findUnique.mockResolvedValue({
        ...mockSession,
        status: SessionStatus.COMPLETED,
      } as any);

      await expect(
        service.submitResponse(mockSessionId, mockUserId, submitDto),
      ).rejects.toThrow(BadRequestException);
    });

    it('should throw NotFoundException for invalid question', async () => {
      questionnaireService.getQuestionById.mockResolvedValue(null);

      await expect(
        service.submitResponse(mockSessionId, mockUserId, submitDto),
      ).rejects.toThrow(NotFoundException);
    });

    it('should update session progress after response', async () => {
      await service.submitResponse(mockSessionId, mockUserId, submitDto);

      expect(prismaService.session.update).toHaveBeenCalledWith({
        where: { id: mockSessionId },
        data: expect.objectContaining({
          progress: expect.objectContaining({
            percentage: expect.any(Number),
            answered: expect.any(Number),
          }),
        }),
      });
    });

    it('should handle validation errors for required fields', async () => {
      const result = await service.submitResponse(mockSessionId, mockUserId, {
        questionId: 'q1',
        value: '',
      });

      expect(result.validationResult.isValid).toBe(false);
      expect(result.validationResult.errors).toContain('This field is required');
    });
  });

  describe('completeSession', () => {
    it('should complete session successfully', async () => {
      prismaService.session.findUnique.mockResolvedValue(mockSession as any);
      prismaService.session.update.mockResolvedValue({
        ...mockSession,
        status: SessionStatus.COMPLETED,
        completedAt: new Date(),
      } as any);
      questionnaireService.getTotalQuestionCount.mockResolvedValue(10);

      const result = await service.completeSession(mockSessionId, mockUserId);

      expect(result.status).toBe(SessionStatus.COMPLETED);
      expect(prismaService.session.update).toHaveBeenCalledWith({
        where: { id: mockSessionId },
        data: {
          status: SessionStatus.COMPLETED,
          completedAt: expect.any(Date),
        },
        include: expect.any(Object),
      });
    });

    it('should throw BadRequestException for already completed session', async () => {
      prismaService.session.findUnique.mockResolvedValue({
        ...mockSession,
        status: SessionStatus.COMPLETED,
      } as any);

      await expect(
        service.completeSession(mockSessionId, mockUserId),
      ).rejects.toThrow(BadRequestException);
    });

    it('should throw ForbiddenException for unauthorized user', async () => {
      prismaService.session.findUnique.mockResolvedValue(mockSession as any);

      await expect(
        service.completeSession(mockSessionId, 'different-user'),
      ).rejects.toThrow(ForbiddenException);
    });
  });

  describe('validateResponse', () => {
    it('should validate minLength constraint', async () => {
      const questionWithMinLength = {
        ...mockQuestion,
        validationRules: { minLength: 10 },
      };
      questionnaireService.getQuestionById.mockResolvedValue(
        questionWithMinLength as any,
      );
      prismaService.session.findUnique.mockResolvedValue(mockSession as any);
      prismaService.response.upsert.mockResolvedValue({
        id: 'response-1',
        isValid: false,
        answeredAt: new Date(),
      } as any);
      prismaService.response.findMany.mockResolvedValue([]);
      adaptiveLogicService.getVisibleQuestions.mockResolvedValue([]);
      prismaService.session.update.mockResolvedValue(mockSession as any);

      const result = await service.submitResponse(mockSessionId, mockUserId, {
        questionId: 'q1',
        value: 'short',
      });

      expect(result.validationResult.errors).toContain(
        'Minimum length is 10 characters',
      );
    });

    it('should validate maxLength constraint', async () => {
      const questionWithMaxLength = {
        ...mockQuestion,
        validationRules: { maxLength: 5 },
      };
      questionnaireService.getQuestionById.mockResolvedValue(
        questionWithMaxLength as any,
      );
      prismaService.session.findUnique.mockResolvedValue(mockSession as any);
      prismaService.response.upsert.mockResolvedValue({
        id: 'response-1',
        isValid: false,
        answeredAt: new Date(),
      } as any);
      prismaService.response.findMany.mockResolvedValue([]);
      adaptiveLogicService.getVisibleQuestions.mockResolvedValue([]);
      prismaService.session.update.mockResolvedValue(mockSession as any);

      const result = await service.submitResponse(mockSessionId, mockUserId, {
        questionId: 'q1',
        value: 'this is too long',
      });

      expect(result.validationResult.errors).toContain(
        'Maximum length is 5 characters',
      );
    });

    it('should validate numeric min constraint', async () => {
      const questionWithMin = {
        ...mockQuestion,
        type: QuestionType.NUMBER,
        validationRules: { min: 10 },
      };
      questionnaireService.getQuestionById.mockResolvedValue(
        questionWithMin as any,
      );
      prismaService.session.findUnique.mockResolvedValue(mockSession as any);
      prismaService.response.upsert.mockResolvedValue({
        id: 'response-1',
        isValid: false,
        answeredAt: new Date(),
      } as any);
      prismaService.response.findMany.mockResolvedValue([]);
      adaptiveLogicService.getVisibleQuestions.mockResolvedValue([]);
      prismaService.session.update.mockResolvedValue(mockSession as any);

      const result = await service.submitResponse(mockSessionId, mockUserId, {
        questionId: 'q1',
        value: 5,
      });

      expect(result.validationResult.errors).toContain('Minimum value is 10');
    });
  });

  describe('calculateProgress', () => {
    it('should calculate progress correctly', async () => {
      prismaService.session.findUnique.mockResolvedValue(mockSession as any);
      prismaService.response.findMany.mockResolvedValue([
        { questionId: 'q1' },
        { questionId: 'q2' },
      ] as any);
      questionnaireService.getQuestionById.mockResolvedValue(mockQuestion as any);
      adaptiveLogicService.getVisibleQuestions.mockResolvedValue([
        { id: 'q1' },
        { id: 'q2' },
        { id: 'q3' },
        { id: 'q4' },
      ] as any);
      prismaService.section.findUnique.mockResolvedValue({
        id: 'section-1',
        name: 'Section 1',
      } as any);

      const result = await service.getNextQuestion(mockSessionId, mockUserId);

      // 2 answered out of 4 visible = 50%
      expect(result.overallProgress.percentage).toBe(50);
      expect(result.overallProgress.answeredQuestions).toBe(2);
      expect(result.overallProgress.totalQuestions).toBe(4);
    });

    it('should handle zero total questions', async () => {
      prismaService.session.findUnique.mockResolvedValue(mockSession as any);
      prismaService.response.findMany.mockResolvedValue([]);
      questionnaireService.getQuestionById.mockResolvedValue(mockQuestion as any);
      adaptiveLogicService.getVisibleQuestions.mockResolvedValue([]);
      prismaService.section.findUnique.mockResolvedValue({
        id: 'section-1',
        name: 'Section 1',
      } as any);

      const result = await service.getNextQuestion(mockSessionId, mockUserId);

      expect(result.overallProgress.percentage).toBe(0);
    });
  });

  describe('findNextUnansweredQuestion', () => {
    it('should find next unanswered question after current', async () => {
      prismaService.session.findUnique.mockResolvedValue(mockSession as any);
      questionnaireService.getQuestionById.mockResolvedValue(mockQuestion as any);
      prismaService.response.upsert.mockResolvedValue({
        id: 'response-1',
        answeredAt: new Date(),
      } as any);
      prismaService.response.findMany.mockResolvedValue([
        { questionId: 'q1', value: 'answer' },
      ] as any);
      adaptiveLogicService.getVisibleQuestions.mockResolvedValue([
        { id: 'q1', sectionId: 'section-1' },
        { id: 'q2', sectionId: 'section-1' },
        { id: 'q3', sectionId: 'section-2' },
      ] as any);
      prismaService.session.update.mockResolvedValue(mockSession as any);

      await service.submitResponse(mockSessionId, mockUserId, {
        questionId: 'q1',
        value: 'answer',
      });

      expect(prismaService.session.update).toHaveBeenCalledWith({
        where: { id: mockSessionId },
        data: expect.objectContaining({
          currentQuestionId: 'q2',
        }),
      });
    });
  });

  describe('continueSession', () => {
    const mockSessionWithQuestionnaire = {
      ...mockSession,
      questionnaire: {
        ...mockQuestionnaire,
        sections: [
          {
            id: 'section-1',
            name: 'Section 1',
            orderIndex: 0,
          },
        ],
      },
    };

    beforeEach(() => {
      prismaService.session.findUnique.mockResolvedValue(mockSessionWithQuestionnaire as any);
      prismaService.response.findMany.mockResolvedValue([]);
      adaptiveLogicService.getVisibleQuestions.mockResolvedValue([
        { ...mockQuestion, id: 'q1', isRequired: true },
        { ...mockQuestion, id: 'q2', isRequired: false },
      ] as any);
      questionnaireService.getTotalQuestionCount.mockResolvedValue(10);
      prismaService.session.update.mockResolvedValue(mockSession as any);
    });

    it('should return session state with next questions', async () => {
      const result = await service.continueSession(mockSessionId, mockUserId, 1);

      expect(result.session.id).toBe(mockSessionId);
      expect(result.nextQuestions).toHaveLength(1);
      expect(result.overallProgress).toBeDefined();
      expect(result.isComplete).toBe(false);
    });

    it('should return multiple questions when requested', async () => {
      const result = await service.continueSession(mockSessionId, mockUserId, 3);

      // Should return up to 2 questions (all unanswered visible questions)
      expect(result.nextQuestions.length).toBeLessThanOrEqual(3);
    });

    it('should calculate canComplete correctly when required questions unanswered', async () => {
      prismaService.response.findMany.mockResolvedValue([]);

      const result = await service.continueSession(mockSessionId, mockUserId, 1);

      expect(result.canComplete).toBe(false);
    });

    it('should calculate canComplete correctly when all required questions answered', async () => {
      prismaService.response.findMany.mockResolvedValue([
        { questionId: 'q1', value: 'answer' },
      ] as any);
      adaptiveLogicService.getVisibleQuestions.mockResolvedValue([
        { ...mockQuestion, id: 'q1', isRequired: true },
        { ...mockQuestion, id: 'q2', isRequired: false },
      ] as any);

      const result = await service.continueSession(mockSessionId, mockUserId, 1);

      expect(result.canComplete).toBe(true);
    });

    it('should return isComplete true for completed sessions', async () => {
      prismaService.session.findUnique.mockResolvedValue({
        ...mockSessionWithQuestionnaire,
        status: SessionStatus.COMPLETED,
      } as any);

      const result = await service.continueSession(mockSessionId, mockUserId, 1);

      expect(result.isComplete).toBe(true);
      expect(result.nextQuestions).toHaveLength(0);
    });

    it('should throw NotFoundException for non-existent session', async () => {
      prismaService.session.findUnique.mockResolvedValue(null);

      await expect(
        service.continueSession('non-existent', mockUserId, 1),
      ).rejects.toThrow(NotFoundException);
    });

    it('should throw ForbiddenException for unauthorized access', async () => {
      await expect(
        service.continueSession(mockSessionId, 'different-user', 1),
      ).rejects.toThrow(ForbiddenException);
    });

    it('should include adaptive state information', async () => {
      const result = await service.continueSession(mockSessionId, mockUserId, 1);

      expect(result.adaptiveState).toBeDefined();
      expect(result.adaptiveState.visibleQuestionCount).toBe(2);
      expect(result.adaptiveState.skippedQuestionCount).toBe(8); // 10 total - 2 visible
    });

    it('should include section progress information', async () => {
      const result = await service.continueSession(mockSessionId, mockUserId, 1);

      expect(result.currentSection).toBeDefined();
      expect(result.currentSection.id).toBe('section-1');
      expect(result.currentSection.progress).toBeDefined();
    });

    it('should update lastActivityAt for active sessions', async () => {
      await service.continueSession(mockSessionId, mockUserId, 1);

      expect(prismaService.session.update).toHaveBeenCalledWith({
        where: { id: mockSessionId },
        data: { lastActivityAt: expect.any(Date) },
      });
    });

    it('should not update lastActivityAt for completed sessions', async () => {
      prismaService.session.findUnique.mockResolvedValue({
        ...mockSessionWithQuestionnaire,
        status: SessionStatus.COMPLETED,
      } as any);

      await service.continueSession(mockSessionId, mockUserId, 1);

      expect(prismaService.session.update).not.toHaveBeenCalled();
    });

    it('should skip already answered questions', async () => {
      prismaService.response.findMany.mockResolvedValue([
        { questionId: 'q1', value: 'answer' },
      ] as any);

      const result = await service.continueSession(mockSessionId, mockUserId, 2);

      // q1 is answered, so only q2 should be returned
      const questionIds = result.nextQuestions.map(q => q.id);
      expect(questionIds).not.toContain('q1');
    });
  });
});

```

## c:\Users\avi\OneDrive - BAS & More\Qoder Repo\Quiz-to-build\Quiz-to-build\apps\api\nest-cli.json
```
{
  "$schema": "https://json.schemastore.org/nest-cli",
  "collection": "@nestjs/schematics",
  "sourceRoot": "src",
  "entryFile": "apps/api/src/main",
  "compilerOptions": {
    "deleteOutDir": true,
    "webpack": false,
    "tsConfigPath": "tsconfig.build.json"
  }
}
```

## c:\Users\avi\OneDrive - BAS & More\Qoder Repo\Quiz-to-build\Quiz-to-build\apps\api\src\modules\admin\services\admin-audit.service.ts
```
import { Injectable, Logger } from '@nestjs/common';
import { PrismaService } from '@libs/database';
import { Request } from 'express';

export interface AuditLogParams {
  userId: string;
  action: string;
  resourceType: 'Questionnaire' | 'Section' | 'Question' | 'VisibilityRule';
  resourceId: string;
  changes?: { before?: unknown; after?: unknown };
  request?: Request;
}

@Injectable()
export class AdminAuditService {
  private readonly logger = new Logger(AdminAuditService.name);

  constructor(private readonly prisma: PrismaService) { }

  async log(params: AuditLogParams): Promise<void> {
    const { userId, action, resourceType, resourceId, changes, request } = params;

    try {
      await this.prisma.auditLog.create({
        data: {
          userId,
          action,
          resourceType,
          resourceId,
          changes: changes ? JSON.parse(JSON.stringify(changes)) : null,
          ipAddress: request?.ip ?? request?.socket?.remoteAddress ?? null,
          userAgent: request?.headers?.['user-agent'] ?? null,
          requestId: request?.headers?.['x-request-id'] as string ?? null,
        },
      });

      this.logger.log(
        `Audit: ${action} on ${resourceType}:${resourceId} by user ${userId}`,
      );
    } catch (error) {
      this.logger.error(
        `Failed to create audit log: ${error instanceof Error ? error.message : 'Unknown error'}`,
        error instanceof Error ? error.stack : undefined,
      );
    }
  }
}

```

## c:\Users\avi\OneDrive - BAS & More\Qoder Repo\Quiz-to-build\Quiz-to-build\apps\api\src\modules\admin\services\admin-questionnaire.service.ts
```
import {
  Injectable,
  NotFoundException,
  BadRequestException,
} from '@nestjs/common';
import { PrismaService } from '@libs/database';
import {
  Questionnaire,
  Section,
  Question,
  VisibilityRule,
  Prisma,
} from '@prisma/client';
import { PaginationDto } from '@libs/shared';
import { AdminAuditService } from './admin-audit.service';
import {
  CreateQuestionnaireDto,
  UpdateQuestionnaireDto,
  CreateSectionDto,
  UpdateSectionDto,
  ReorderSectionsDto,
  CreateQuestionDto,
  UpdateQuestionDto,
  ReorderQuestionsDto,
  CreateVisibilityRuleDto,
  UpdateVisibilityRuleDto,
} from '../dto';

export interface PaginatedResult<T> {
  items: T[];
  total: number;
}

export interface QuestionnaireWithDetails extends Questionnaire {
  sections: (Section & {
    questions: (Question & {
      visibilityRules: VisibilityRule[];
    })[];
  })[];
  _count: {
    sessions: number;
  };
}

@Injectable()
export class AdminQuestionnaireService {
  constructor(
    private readonly prisma: PrismaService,
    private readonly auditService: AdminAuditService,
  ) { }

  // ============================================================================
  // QUESTIONNAIRE CRUD
  // ============================================================================

  async findAllQuestionnaires(
    pagination: PaginationDto,
  ): Promise<PaginatedResult<Questionnaire>> {
    const [items, total] = await Promise.all([
      this.prisma.questionnaire.findMany({
        skip: pagination.skip,
        take: pagination.limit,
        orderBy: { createdAt: 'desc' },
        include: {
          _count: {
            select: { sections: true, sessions: true },
          },
        },
      }),
      this.prisma.questionnaire.count(),
    ]);

    return { items, total };
  }

  async findQuestionnaireById(id: string): Promise<QuestionnaireWithDetails> {
    const questionnaire = await this.prisma.questionnaire.findUnique({
      where: { id },
      include: {
        sections: {
          orderBy: { orderIndex: 'asc' },
          include: {
            questions: {
              orderBy: { orderIndex: 'asc' },
              include: {
                visibilityRules: {
                  orderBy: { priority: 'desc' },
                },
              },
            },
          },
        },
        _count: {
          select: { sessions: true },
        },
      },
    });

    if (!questionnaire) {
      throw new NotFoundException(`Questionnaire with ID ${id} not found`);
    }

    return questionnaire;
  }

  async createQuestionnaire(
    dto: CreateQuestionnaireDto,
    userId: string,
  ): Promise<Questionnaire> {
    const questionnaire = await this.prisma.questionnaire.create({
      data: {
        name: dto.name,
        description: dto.description,
        industry: dto.industry,
        isDefault: dto.isDefault ?? false,
        estimatedTime: dto.estimatedTime,
        metadata: (dto.metadata ?? {}) as Prisma.InputJsonValue,
        createdById: userId,
      },
    });

    await this.auditService.log({
      userId,
      action: 'CREATE_QUESTIONNAIRE',
      resourceType: 'Questionnaire',
      resourceId: questionnaire.id,
      changes: { after: questionnaire },
    });

    return questionnaire;
  }

  async updateQuestionnaire(
    id: string,
    dto: UpdateQuestionnaireDto,
    userId: string,
  ): Promise<Questionnaire> {
    const existing = await this.prisma.questionnaire.findUnique({
      where: { id },
    });

    if (!existing) {
      throw new NotFoundException(`Questionnaire with ID ${id} not found`);
    }

    const questionnaire = await this.prisma.questionnaire.update({
      where: { id },
      data: {
        name: dto.name,
        description: dto.description,
        industry: dto.industry,
        isDefault: dto.isDefault,
        isActive: dto.isActive,
        estimatedTime: dto.estimatedTime,
        metadata: dto.metadata as Prisma.InputJsonValue,
      },
    });

    await this.auditService.log({
      userId,
      action: 'UPDATE_QUESTIONNAIRE',
      resourceType: 'Questionnaire',
      resourceId: id,
      changes: { before: existing, after: questionnaire },
    });

    return questionnaire;
  }

  async deleteQuestionnaire(id: string, userId: string): Promise<void> {
    const existing = await this.prisma.questionnaire.findUnique({
      where: { id },
      include: { _count: { select: { sessions: true } } },
    });

    if (!existing) {
      throw new NotFoundException(`Questionnaire with ID ${id} not found`);
    }

    // Soft delete by setting isActive to false
    await this.prisma.questionnaire.update({
      where: { id },
      data: { isActive: false },
    });

    await this.auditService.log({
      userId,
      action: 'DELETE_QUESTIONNAIRE',
      resourceType: 'Questionnaire',
      resourceId: id,
      changes: { before: existing },
    });
  }

  // ============================================================================
  // SECTION CRUD
  // ============================================================================

  async createSection(
    questionnaireId: string,
    dto: CreateSectionDto,
    userId: string,
  ): Promise<Section> {
    const questionnaire = await this.prisma.questionnaire.findUnique({
      where: { id: questionnaireId },
      include: { sections: { select: { orderIndex: true } } },
    });

    if (!questionnaire) {
      throw new NotFoundException(
        `Questionnaire with ID ${questionnaireId} not found`,
      );
    }

    // Auto-calculate orderIndex if not provided
    const maxOrder = questionnaire.sections.reduce(
      (max, s) => Math.max(max, s.orderIndex),
      -1,
    );
    const orderIndex = dto.orderIndex ?? maxOrder + 1;

    const section = await this.prisma.section.create({
      data: {
        questionnaireId,
        name: dto.name,
        description: dto.description,
        icon: dto.icon,
        estimatedTime: dto.estimatedTime,
        orderIndex,
        metadata: (dto.metadata ?? {}) as Prisma.InputJsonValue,
      },
    });

    await this.auditService.log({
      userId,
      action: 'CREATE_SECTION',
      resourceType: 'Section',
      resourceId: section.id,
      changes: { after: section },
    });

    return section;
  }

  async updateSection(
    id: string,
    dto: UpdateSectionDto,
    userId: string,
  ): Promise<Section> {
    const existing = await this.prisma.section.findUnique({ where: { id } });

    if (!existing) {
      throw new NotFoundException(`Section with ID ${id} not found`);
    }

    const section = await this.prisma.section.update({
      where: { id },
      data: {
        name: dto.name,
        description: dto.description,
        icon: dto.icon,
        estimatedTime: dto.estimatedTime,
        orderIndex: dto.orderIndex,
        metadata: dto.metadata as Prisma.InputJsonValue,
      },
    });

    await this.auditService.log({
      userId,
      action: 'UPDATE_SECTION',
      resourceType: 'Section',
      resourceId: id,
      changes: { before: existing, after: section },
    });

    return section;
  }

  async deleteSection(id: string, userId: string): Promise<void> {
    const existing = await this.prisma.section.findUnique({
      where: { id },
      include: { _count: { select: { questions: true } } },
    });

    if (!existing) {
      throw new NotFoundException(`Section with ID ${id} not found`);
    }

    if (existing._count.questions > 0) {
      throw new BadRequestException(
        `Cannot delete section with ${existing._count.questions} questions. Delete questions first.`,
      );
    }

    await this.prisma.section.delete({ where: { id } });

    await this.auditService.log({
      userId,
      action: 'DELETE_SECTION',
      resourceType: 'Section',
      resourceId: id,
      changes: { before: existing },
    });
  }

  async reorderSections(
    questionnaireId: string,
    dto: ReorderSectionsDto,
    userId: string,
  ): Promise<Section[]> {
    const questionnaire = await this.prisma.questionnaire.findUnique({
      where: { id: questionnaireId },
    });

    if (!questionnaire) {
      throw new NotFoundException(
        `Questionnaire with ID ${questionnaireId} not found`,
      );
    }

    const sections = await this.prisma.$transaction(
      dto.items.map((item) =>
        this.prisma.section.update({
          where: { id: item.id },
          data: { orderIndex: item.orderIndex },
        }),
      ),
    );

    await this.auditService.log({
      userId,
      action: 'REORDER_SECTIONS',
      resourceType: 'Questionnaire',
      resourceId: questionnaireId,
      changes: { after: dto.items },
    });

    return sections;
  }

  // ============================================================================
  // QUESTION CRUD
  // ============================================================================

  async createQuestion(
    sectionId: string,
    dto: CreateQuestionDto,
    userId: string,
  ): Promise<Question> {
    const section = await this.prisma.section.findUnique({
      where: { id: sectionId },
      include: { questions: { select: { orderIndex: true } } },
    });

    if (!section) {
      throw new NotFoundException(`Section with ID ${sectionId} not found`);
    }

    // Auto-calculate orderIndex if not provided
    const maxOrder = section.questions.reduce(
      (max, q) => Math.max(max, q.orderIndex),
      -1,
    );
    const orderIndex = dto.orderIndex ?? maxOrder + 1;

    const question = await this.prisma.question.create({
      data: {
        sectionId,
        text: dto.text,
        type: dto.type,
        helpText: dto.helpText,
        explanation: dto.explanation,
        placeholder: dto.placeholder,
        isRequired: dto.isRequired ?? false,
        options: dto.options as unknown as Prisma.InputJsonValue,
        validationRules: dto.validationRules as Prisma.InputJsonValue,
        defaultValue: dto.defaultValue as Prisma.InputJsonValue,
        suggestedAnswer: dto.suggestedAnswer as Prisma.InputJsonValue,
        industryTags: dto.industryTags ?? [],
        documentMappings: dto.documentMappings as Prisma.InputJsonValue,
        orderIndex,
        metadata: (dto.metadata ?? {}) as Prisma.InputJsonValue,
      },
    });

    await this.auditService.log({
      userId,
      action: 'CREATE_QUESTION',
      resourceType: 'Question',
      resourceId: question.id,
      changes: { after: question },
    });

    return question;
  }

  async updateQuestion(
    id: string,
    dto: UpdateQuestionDto,
    userId: string,
  ): Promise<Question> {
    const existing = await this.prisma.question.findUnique({ where: { id } });

    if (!existing) {
      throw new NotFoundException(`Question with ID ${id} not found`);
    }

    const question = await this.prisma.question.update({
      where: { id },
      data: {
        text: dto.text,
        type: dto.type,
        helpText: dto.helpText,
        explanation: dto.explanation,
        placeholder: dto.placeholder,
        isRequired: dto.isRequired,
        options: dto.options as unknown as Prisma.InputJsonValue,
        validationRules: dto.validationRules as Prisma.InputJsonValue,
        defaultValue: dto.defaultValue as Prisma.InputJsonValue,
        suggestedAnswer: dto.suggestedAnswer as Prisma.InputJsonValue,
        industryTags: dto.industryTags,
        documentMappings: dto.documentMappings as Prisma.InputJsonValue,
        orderIndex: dto.orderIndex,
        metadata: dto.metadata as Prisma.InputJsonValue,
      },
    });

    await this.auditService.log({
      userId,
      action: 'UPDATE_QUESTION',
      resourceType: 'Question',
      resourceId: id,
      changes: { before: existing, after: question },
    });

    return question;
  }

  async deleteQuestion(id: string, userId: string): Promise<void> {
    const existing = await this.prisma.question.findUnique({
      where: { id },
      include: { _count: { select: { responses: true } } },
    });

    if (!existing) {
      throw new NotFoundException(`Question with ID ${id} not found`);
    }

    if (existing._count.responses > 0) {
      throw new BadRequestException(
        `Cannot delete question with ${existing._count.responses} responses. This would corrupt session data.`,
      );
    }

    await this.prisma.question.delete({ where: { id } });

    await this.auditService.log({
      userId,
      action: 'DELETE_QUESTION',
      resourceType: 'Question',
      resourceId: id,
      changes: { before: existing },
    });
  }

  async reorderQuestions(
    sectionId: string,
    dto: ReorderQuestionsDto,
    userId: string,
  ): Promise<Question[]> {
    const section = await this.prisma.section.findUnique({
      where: { id: sectionId },
    });

    if (!section) {
      throw new NotFoundException(`Section with ID ${sectionId} not found`);
    }

    const questions = await this.prisma.$transaction(
      dto.items.map((item) =>
        this.prisma.question.update({
          where: { id: item.id },
          data: { orderIndex: item.orderIndex },
        }),
      ),
    );

    await this.auditService.log({
      userId,
      action: 'REORDER_QUESTIONS',
      resourceType: 'Section',
      resourceId: sectionId,
      changes: { after: dto.items },
    });

    return questions;
  }

  // ============================================================================
  // VISIBILITY RULE CRUD
  // ============================================================================

  async findRulesByQuestion(questionId: string): Promise<VisibilityRule[]> {
    const question = await this.prisma.question.findUnique({
      where: { id: questionId },
    });

    if (!question) {
      throw new NotFoundException(`Question with ID ${questionId} not found`);
    }

    return this.prisma.visibilityRule.findMany({
      where: { questionId },
      orderBy: { priority: 'desc' },
    });
  }

  async createVisibilityRule(
    questionId: string,
    dto: CreateVisibilityRuleDto,
    userId: string,
  ): Promise<VisibilityRule> {
    const question = await this.prisma.question.findUnique({
      where: { id: questionId },
    });

    if (!question) {
      throw new NotFoundException(`Question with ID ${questionId} not found`);
    }

    const rule = await this.prisma.visibilityRule.create({
      data: {
        questionId,
        condition: dto.condition as Prisma.InputJsonValue,
        action: dto.action,
        targetQuestionIds: dto.targetQuestionIds,
        priority: dto.priority ?? 0,
        isActive: dto.isActive ?? true,
      },
    });

    await this.auditService.log({
      userId,
      action: 'CREATE_VISIBILITY_RULE',
      resourceType: 'VisibilityRule',
      resourceId: rule.id,
      changes: { after: rule },
    });

    return rule;
  }

  async updateVisibilityRule(
    id: string,
    dto: UpdateVisibilityRuleDto,
    userId: string,
  ): Promise<VisibilityRule> {
    const existing = await this.prisma.visibilityRule.findUnique({
      where: { id },
    });

    if (!existing) {
      throw new NotFoundException(`Visibility rule with ID ${id} not found`);
    }

    const rule = await this.prisma.visibilityRule.update({
      where: { id },
      data: {
        condition: dto.condition as Prisma.InputJsonValue,
        action: dto.action,
        targetQuestionIds: dto.targetQuestionIds,
        priority: dto.priority,
        isActive: dto.isActive,
      },
    });

    await this.auditService.log({
      userId,
      action: 'UPDATE_VISIBILITY_RULE',
      resourceType: 'VisibilityRule',
      resourceId: id,
      changes: { before: existing, after: rule },
    });

    return rule;
  }

  async deleteVisibilityRule(id: string, userId: string): Promise<void> {
    const existing = await this.prisma.visibilityRule.findUnique({
      where: { id },
    });

    if (!existing) {
      throw new NotFoundException(`Visibility rule with ID ${id} not found`);
    }

    await this.prisma.visibilityRule.delete({ where: { id } });

    await this.auditService.log({
      userId,
      action: 'DELETE_VISIBILITY_RULE',
      resourceType: 'VisibilityRule',
      resourceId: id,
      changes: { before: existing },
    });
  }
}

```

## c:\Users\avi\OneDrive - BAS & More\Qoder Repo\Quiz-to-build\Quiz-to-build\apps\api\src\modules\document-generator\controllers\document-admin.controller.ts
```
import {
  Controller,
  Get,
  Post,
  Patch,
  Body,
  Param,
  Query,
  UseGuards,
  ParseUUIDPipe,
} from '@nestjs/common';
import {
  ApiTags,
  ApiOperation,
  ApiResponse,
  ApiBearerAuth,
} from '@nestjs/swagger';
import { UserRole } from '@prisma/client';
import { PrismaService } from '@libs/database';
import { JwtAuthGuard } from '../../auth/guards/jwt-auth.guard';
import { RolesGuard } from '../../auth/guards/roles.guard';
import { Roles } from '../../auth/decorators/roles.decorator';
import { CurrentUser } from '../../auth/decorators/user.decorator';
import { AuthenticatedUser } from '../../auth/auth.service';
import { PaginationDto } from '@libs/shared';
import { DocumentGeneratorService } from '../services/document-generator.service';
import {
  CreateDocumentTypeDto,
  UpdateDocumentTypeDto,
  RejectDocumentDto,
  DocumentResponseDto,
  DocumentTypeResponseDto,
} from '../dto';

@ApiTags('admin/documents')
@Controller('admin')
@UseGuards(JwtAuthGuard, RolesGuard)
@ApiBearerAuth('JWT-auth')
export class DocumentAdminController {
  constructor(
    private readonly prisma: PrismaService,
    private readonly documentGeneratorService: DocumentGeneratorService,
  ) { }

  // ==========================================================================
  // DOCUMENT TYPE MANAGEMENT
  // ==========================================================================

  @Get('document-types')
  @Roles(UserRole.ADMIN, UserRole.SUPER_ADMIN)
  @ApiOperation({ summary: 'List all document types' })
  @ApiResponse({ status: 200, description: 'List of document types' })
  async listDocumentTypes(@Query() pagination: PaginationDto) {
    const [items, total] = await Promise.all([
      this.prisma.documentType.findMany({
        skip: pagination.skip,
        take: pagination.limit,
        orderBy: [{ category: 'asc' }, { name: 'asc' }],
      }),
      this.prisma.documentType.count(),
    ]);

    return {
      items,
      pagination: {
        page: pagination.page ?? 1,
        limit: pagination.limit ?? 20,
        total,
        totalPages: Math.ceil(total / (pagination.limit ?? 20)),
      },
    };
  }

  @Get('document-types/:id')
  @Roles(UserRole.ADMIN, UserRole.SUPER_ADMIN)
  @ApiOperation({ summary: 'Get document type details' })
  @ApiResponse({ status: 200, description: 'Document type details' })
  @ApiResponse({ status: 404, description: 'Document type not found' })
  async getDocumentType(
    @Param('id', ParseUUIDPipe) id: string,
  ): Promise<DocumentTypeResponseDto> {
    const documentType = await this.prisma.documentType.findUnique({
      where: { id },
      include: {
        standardMappings: {
          include: { standard: true },
        },
        _count: { select: { documents: true } },
      },
    });

    if (!documentType) {
      throw new Error(`Document type with ID ${id} not found`);
    }

    return documentType as unknown as DocumentTypeResponseDto;
  }

  @Post('document-types')
  @Roles(UserRole.ADMIN, UserRole.SUPER_ADMIN)
  @ApiOperation({ summary: 'Create document type' })
  @ApiResponse({ status: 201, description: 'Document type created' })
  async createDocumentType(
    @Body() dto: CreateDocumentTypeDto,
  ): Promise<DocumentTypeResponseDto> {
    return this.prisma.documentType.create({
      data: {
        name: dto.name,
        slug: dto.slug,
        description: dto.description,
        category: dto.category,
        templatePath: dto.templatePath,
        requiredQuestions: dto.requiredQuestions ?? [],
        outputFormats: dto.outputFormats ?? ['DOCX'],
        estimatedPages: dto.estimatedPages,
        isActive: dto.isActive ?? true,
      },
    }) as unknown as Promise<DocumentTypeResponseDto>;
  }

  @Patch('document-types/:id')
  @Roles(UserRole.ADMIN, UserRole.SUPER_ADMIN)
  @ApiOperation({ summary: 'Update document type' })
  @ApiResponse({ status: 200, description: 'Document type updated' })
  @ApiResponse({ status: 404, description: 'Document type not found' })
  async updateDocumentType(
    @Param('id', ParseUUIDPipe) id: string,
    @Body() dto: UpdateDocumentTypeDto,
  ): Promise<DocumentTypeResponseDto> {
    return this.prisma.documentType.update({
      where: { id },
      data: {
        name: dto.name,
        slug: dto.slug,
        description: dto.description,
        category: dto.category,
        templatePath: dto.templatePath,
        requiredQuestions: dto.requiredQuestions,
        outputFormats: dto.outputFormats,
        estimatedPages: dto.estimatedPages,
        isActive: dto.isActive,
      },
    }) as unknown as Promise<DocumentTypeResponseDto>;
  }

  // ==========================================================================
  // DOCUMENT REVIEW MANAGEMENT
  // ==========================================================================

  @Get('documents/pending-review')
  @Roles(UserRole.ADMIN, UserRole.SUPER_ADMIN)
  @ApiOperation({ summary: 'List documents pending review' })
  @ApiResponse({ status: 200, description: 'List of documents pending review' })
  async getPendingReviewDocuments(): Promise<DocumentResponseDto[]> {
    const documents = await this.documentGeneratorService.getPendingReviewDocuments();
    return documents.map((doc) => ({
      id: doc.id,
      sessionId: doc.sessionId,
      documentTypeId: doc.documentTypeId,
      status: doc.status,
      format: doc.format,
      fileName: doc.fileName ?? undefined,
      fileSize: doc.fileSize?.toString() ?? undefined,
      version: doc.version,
      generatedAt: doc.generatedAt ?? undefined,
      createdAt: doc.createdAt,
      updatedAt: doc.updatedAt,
      documentType: {
        id: doc.documentType.id,
        name: doc.documentType.name,
        slug: doc.documentType.slug,
        description: doc.documentType.description ?? undefined,
        category: doc.documentType.category,
        estimatedPages: doc.documentType.estimatedPages ?? undefined,
        isActive: doc.documentType.isActive,
      },
    }));
  }

  @Patch('documents/:id/approve')
  @Roles(UserRole.ADMIN, UserRole.SUPER_ADMIN)
  @ApiOperation({ summary: 'Approve a document' })
  @ApiResponse({ status: 200, description: 'Document approved' })
  @ApiResponse({ status: 400, description: 'Document not in pending review status' })
  @ApiResponse({ status: 404, description: 'Document not found' })
  async approveDocument(
    @Param('id', ParseUUIDPipe) id: string,
    @CurrentUser() user: AuthenticatedUser,
  ) {
    const document = await this.documentGeneratorService.approveDocument(
      id,
      user.id,
    );
    return {
      message: 'Document approved successfully',
      document: {
        id: document.id,
        status: document.status,
        approvedAt: document.approvedAt,
      },
    };
  }

  @Patch('documents/:id/reject')
  @Roles(UserRole.ADMIN, UserRole.SUPER_ADMIN)
  @ApiOperation({ summary: 'Reject a document' })
  @ApiResponse({ status: 200, description: 'Document rejected' })
  @ApiResponse({ status: 400, description: 'Document not in pending review status' })
  @ApiResponse({ status: 404, description: 'Document not found' })
  async rejectDocument(
    @Param('id', ParseUUIDPipe) id: string,
    @Body() dto: RejectDocumentDto,
    @CurrentUser() user: AuthenticatedUser,
  ) {
    const document = await this.documentGeneratorService.rejectDocument(
      id,
      user.id,
      dto.reason,
    );
    return {
      message: 'Document rejected',
      document: {
        id: document.id,
        status: document.status,
        rejectionReason: document.rejectionReason,
      },
    };
  }
}

```

## c:\Users\avi\OneDrive - BAS & More\Qoder Repo\Quiz-to-build\Quiz-to-build\apps\api\src\modules\document-generator\controllers\document.controller.ts
```
import {
  Controller,
  Get,
  Post,
  Body,
  Param,
  Query,
  UseGuards,
  ParseUUIDPipe,
} from '@nestjs/common';
import {
  ApiTags,
  ApiOperation,
  ApiResponse,
  ApiBearerAuth,
  ApiQuery,
} from '@nestjs/swagger';
import { JwtAuthGuard } from '../../auth/guards/jwt-auth.guard';
import { CurrentUser } from '../../auth/decorators/user.decorator';
import { AuthenticatedUser } from '../../auth/auth.service';
import { DocumentGeneratorService } from '../services/document-generator.service';
import {
  RequestGenerationDto,
  DocumentResponseDto,
  DocumentTypeResponseDto,
  DownloadUrlResponseDto,
} from '../dto';

@ApiTags('documents')
@Controller('documents')
@UseGuards(JwtAuthGuard)
@ApiBearerAuth('JWT-auth')
export class DocumentController {
  constructor(
    private readonly documentGeneratorService: DocumentGeneratorService,
  ) { }

  @Post('generate')
  @ApiOperation({ summary: 'Request document generation for a session' })
  @ApiResponse({ status: 201, description: 'Document generation started', type: DocumentResponseDto })
  @ApiResponse({ status: 400, description: 'Session not completed or missing required questions' })
  @ApiResponse({ status: 404, description: 'Session or document type not found' })
  async generateDocument(
    @Body() dto: RequestGenerationDto,
    @CurrentUser() user: AuthenticatedUser,
  ): Promise<DocumentResponseDto> {
    const document = await this.documentGeneratorService.generateDocument({
      sessionId: dto.sessionId,
      documentTypeId: dto.documentTypeId,
      userId: user.id,
    });

    return this.mapToResponse(document);
  }

  @Get('types')
  @ApiOperation({ summary: 'List available document types' })
  @ApiResponse({ status: 200, description: 'List of document types', type: [DocumentTypeResponseDto] })
  async listDocumentTypes(): Promise<DocumentTypeResponseDto[]> {
    return this.documentGeneratorService.listDocumentTypes() as unknown as Promise<DocumentTypeResponseDto[]>;
  }

  @Get('session/:sessionId')
  @ApiOperation({ summary: 'List all documents for a session' })
  @ApiResponse({ status: 200, description: 'List of documents', type: [DocumentResponseDto] })
  @ApiResponse({ status: 404, description: 'Session not found' })
  async getSessionDocuments(
    @Param('sessionId', ParseUUIDPipe) sessionId: string,
    @CurrentUser() user: AuthenticatedUser,
  ): Promise<DocumentResponseDto[]> {
    const documents = await this.documentGeneratorService.getSessionDocuments(
      sessionId,
      user.id,
    );

    return documents.map((doc) => this.mapToResponse(doc));
  }

  @Get(':id')
  @ApiOperation({ summary: 'Get document details' })
  @ApiResponse({ status: 200, description: 'Document details', type: DocumentResponseDto })
  @ApiResponse({ status: 404, description: 'Document not found' })
  async getDocument(
    @Param('id', ParseUUIDPipe) id: string,
    @CurrentUser() user: AuthenticatedUser,
  ): Promise<DocumentResponseDto> {
    const document = await this.documentGeneratorService.getDocument(id, user.id);
    return this.mapToResponse(document);
  }

  @Get(':id/download')
  @ApiOperation({ summary: 'Get secure download URL for document' })
  @ApiQuery({ name: 'expiresIn', required: false, description: 'URL expiration in minutes (default: 60)' })
  @ApiResponse({ status: 200, description: 'Download URL', type: DownloadUrlResponseDto })
  @ApiResponse({ status: 400, description: 'Document not available for download' })
  @ApiResponse({ status: 404, description: 'Document not found' })
  async getDownloadUrl(
    @Param('id', ParseUUIDPipe) id: string,
    @Query('expiresIn') expiresIn: string,
    @CurrentUser() user: AuthenticatedUser,
  ): Promise<DownloadUrlResponseDto> {
    const expiresInMinutes = expiresIn ? parseInt(expiresIn, 10) : 60;
    const url = await this.documentGeneratorService.getDownloadUrl(
      id,
      user.id,
      expiresInMinutes,
    );

    return {
      url,
      expiresAt: new Date(Date.now() + expiresInMinutes * 60000),
    };
  }

  private mapToResponse(document: {
    id: string;
    sessionId: string;
    documentTypeId: string;
    status: string;
    format: string;
    fileName: string | null;
    fileSize: bigint | null;
    version: number;
    generatedAt: Date | null;
    createdAt: Date;
    updatedAt: Date;
    documentType?: {
      id: string;
      name: string;
      slug: string;
      description: string | null;
      category: string;
      estimatedPages: number | null;
      isActive: boolean;
    };
  }): DocumentResponseDto {
    return {
      id: document.id,
      sessionId: document.sessionId,
      documentTypeId: document.documentTypeId,
      status: document.status as DocumentResponseDto['status'],
      format: document.format,
      fileName: document.fileName ?? undefined,
      fileSize: document.fileSize?.toString() ?? undefined,
      version: document.version,
      generatedAt: document.generatedAt ?? undefined,
      createdAt: document.createdAt,
      updatedAt: document.updatedAt,
      documentType: document.documentType
        ? {
          id: document.documentType.id,
          name: document.documentType.name,
          slug: document.documentType.slug,
          description: document.documentType.description ?? undefined,
          category: document.documentType.category as DocumentTypeResponseDto['category'],
          estimatedPages: document.documentType.estimatedPages ?? undefined,
          isActive: document.documentType.isActive,
        }
        : undefined,
    };
  }
}

```

## c:\Users\avi\OneDrive - BAS & More\Qoder Repo\Quiz-to-build\Quiz-to-build\apps\api\package.json
```
{
  "name": "api",
  "version": "1.0.0",
  "description": "Adaptive Questionnaire System - NestJS API",
  "private": true,
  "scripts": {
    "build": "nest build",
    "dev": "nest start --watch",
    "start": "nest start",
    "start:dev": "nest start --watch",
    "start:debug": "nest start --debug --watch",
    "start:prod": "node dist/apps/api/src/main",
    "test": "jest",
    "test:watch": "jest --watch",
    "test:cov": "jest --coverage",
    "test:debug": "node --inspect-brk -r tsconfig-paths/register -r ts-node/register node_modules/.bin/jest --runInBand",
    "test:e2e": "jest --config ./test/jest-e2e.json",
    "lint": "eslint \"{src,test}/**/*.ts\" --fix"
  },
  "dependencies": {
    "@azure/storage-blob": "^12.17.0",
    "@nestjs/common": "^10.3.0",
    "@nestjs/config": "^3.1.1",
    "@nestjs/core": "^10.3.0",
    "@nestjs/jwt": "^10.2.0",
    "@nestjs/passport": "^10.0.3",
    "@nestjs/platform-express": "^10.3.0",
    "@nestjs/swagger": "^7.2.0",
    "@nestjs/throttler": "^5.1.1",
    "@prisma/client": "^5.8.0",
    "bcrypt": "^5.1.1",
    "class-transformer": "^0.5.1",
    "class-validator": "^0.14.1",
    "docx": "^8.5.0",
    "helmet": "^7.1.0",
    "ioredis": "^5.3.2",
    "passport": "^0.7.0",
    "passport-jwt": "^4.0.1",
    "reflect-metadata": "^0.2.1",
    "rxjs": "^7.8.1",
    "uuid": "^9.0.1"
  },
  "devDependencies": {
    "@nestjs/cli": "^10.3.0",
    "@nestjs/schematics": "^10.1.0",
    "@nestjs/testing": "^10.3.0",
    "@types/bcrypt": "^5.0.2",
    "@types/express": "^4.17.21",
    "@types/jest": "^29.5.11",
    "@types/node": "^20.10.8",
    "@types/passport-jwt": "^4.0.0",
    "@types/supertest": "^6.0.2",
    "@types/uuid": "^9.0.7",
    "jest": "^29.7.0",
    "prisma": "^5.8.0",
    "source-map-support": "^0.5.21",
    "supertest": "^6.3.4",
    "ts-jest": "^29.1.1",
    "ts-loader": "^9.5.1",
    "ts-node": "^10.9.2",
    "tsconfig-paths": "^4.2.0",
    "typescript": "^5.3.3"
  },
  "jest": {
    "moduleFileExtensions": [
      "js",
      "json",
      "ts"
    ],
    "rootDir": "src",
    "testRegex": ".*\\.spec\\.ts$",
    "transform": {
      "^.+\\.(t|j)s$": "ts-jest"
    },
    "collectCoverageFrom": [
      "**/*.(t|j)s",
      "!**/*.module.ts",
      "!**/main.ts"
    ],
    "coverageDirectory": "../coverage",
    "coverageThreshold": {
      "global": {
        "branches": 80,
        "functions": 80,
        "lines": 80,
        "statements": 80
      }
    },
    "testEnvironment": "node",
    "moduleNameMapper": {
      "^@libs/database(.*)$": "<rootDir>/../../libs/database/src$1",
      "^@libs/redis(.*)$": "<rootDir>/../../libs/redis/src$1",
      "^@libs/shared(.*)$": "<rootDir>/../../libs/shared/src$1"
    }
  }
}

```

## c:\Users\avi\OneDrive - BAS & More\Qoder Repo\Quiz-to-build\Quiz-to-build\apps\api\src\modules\document-generator\services\document-builder.service.ts
```
import { Injectable, Logger } from '@nestjs/common';
import {
  Document,
  Packer,
  Paragraph,
  TextRun,
  HeadingLevel,
  Table,
  TableRow,
  TableCell,
  WidthType,
  BorderStyle,
  AlignmentType,
  Header,
  Footer,
  PageNumber,
  NumberFormat,
} from 'docx';
import { DocumentCategory } from '@prisma/client';
import { TemplateData, StandardSection } from './template-engine.service';

export interface DocumentTypeInfo {
  name: string;
  slug: string;
  category: DocumentCategory;
}

@Injectable()
export class DocumentBuilderService {
  private readonly logger = new Logger(DocumentBuilderService.name);

  /**
   * Build a DOCX document from template data
   */
  async buildDocument(
    templateData: TemplateData,
    documentType: DocumentTypeInfo,
  ): Promise<Buffer> {
    this.logger.log(`Building document: ${documentType.name}`);

    const sections = this.buildSections(templateData, documentType);

    const doc = new Document({
      creator: 'Adaptive Questionnaire System',
      title: documentType.name,
      description: `Generated ${documentType.name} document`,
      styles: this.getDocumentStyles(),
      sections: [
        {
          properties: {
            page: {
              margin: {
                top: 1440, // 1 inch = 1440 twips
                right: 1440,
                bottom: 1440,
                left: 1440,
              },
            },
          },
          headers: {
            default: this.buildHeader(documentType.name),
          },
          footers: {
            default: this.buildFooter(),
          },
          children: sections,
        },
      ],
    });

    return Packer.toBuffer(doc);
  }

  /**
   * Build document sections based on category and content
   */
  private buildSections(
    templateData: TemplateData,
    documentType: DocumentTypeInfo,
  ): (Paragraph | Table)[] {
    const sections: (Paragraph | Table)[] = [];

    // Title
    sections.push(this.buildTitle(documentType.name));

    // Document Control section
    sections.push(...this.buildDocumentControl(templateData));

    // Content sections based on category
    switch (documentType.category) {
      case DocumentCategory.CTO:
        sections.push(...this.buildCTOContent(templateData));
        break;
      case DocumentCategory.CFO:
        sections.push(...this.buildCFOContent(templateData));
        break;
      case DocumentCategory.BA:
        sections.push(...this.buildBAContent(templateData));
        break;
    }

    // Standards section for CTO documents
    if (templateData.standards && templateData.standards.length > 0) {
      sections.push(...this.buildStandardsSection(templateData.standards));
    }

    return sections;
  }

  /**
   * Build document title
   */
  private buildTitle(title: string): Paragraph {
    return new Paragraph({
      children: [
        new TextRun({
          text: title,
          bold: true,
          size: 48, // 24pt
        }),
      ],
      heading: HeadingLevel.TITLE,
      alignment: AlignmentType.CENTER,
      spacing: { after: 400 },
    });
  }

  /**
   * Build document control section
   */
  private buildDocumentControl(templateData: TemplateData): (Paragraph | Table)[] {
    return [
      this.buildHeading('Document Control', HeadingLevel.HEADING_1),
      this.buildTable([
        ['Version', templateData.metadata.version],
        ['Date', templateData.metadata.generatedAt.toISOString().split('T')[0]],
        ['Document Type', templateData.metadata.documentType],
        ['Classification', 'Internal'],
      ]),
      this.buildEmptyParagraph(),
    ];
  }

  /**
   * Build CTO document content
   */
  private buildCTOContent(templateData: TemplateData): Paragraph[] {
    const sections: Paragraph[] = [];
    const content = templateData.content;

    // Executive Summary
    if (content.executive_summary) {
      sections.push(this.buildHeading('Executive Summary', HeadingLevel.HEADING_1));
      sections.push(...this.buildContentSection(content.executive_summary));
    }

    // Technical Overview
    if (content.technical_overview || content.architecture) {
      sections.push(this.buildHeading('Technical Overview', HeadingLevel.HEADING_1));
      sections.push(...this.buildContentSection(content.technical_overview ?? content.architecture));
    }

    // Infrastructure
    if (content.infrastructure) {
      sections.push(this.buildHeading('Infrastructure', HeadingLevel.HEADING_1));
      sections.push(...this.buildContentSection(content.infrastructure));
    }

    // Security
    if (content.security) {
      sections.push(this.buildHeading('Security', HeadingLevel.HEADING_1));
      sections.push(...this.buildContentSection(content.security));
    }

    return sections;
  }

  /**
   * Build CFO document content (Business Plan)
   */
  private buildCFOContent(templateData: TemplateData): Paragraph[] {
    const sections: Paragraph[] = [];
    const content = templateData.content;

    // Executive Summary
    if (content.executive_summary) {
      sections.push(this.buildHeading('Executive Summary', HeadingLevel.HEADING_1));
      sections.push(...this.buildContentSection(content.executive_summary));
    }

    // Company Description
    if (content.company_description) {
      sections.push(this.buildHeading('Company Description', HeadingLevel.HEADING_1));
      sections.push(...this.buildContentSection(content.company_description));
    }

    // Market Analysis
    if (content.market_analysis) {
      sections.push(this.buildHeading('Market Analysis', HeadingLevel.HEADING_1));
      sections.push(...this.buildContentSection(content.market_analysis));
    }

    // Financial Projections
    if (content.financial_projections) {
      sections.push(this.buildHeading('Financial Projections', HeadingLevel.HEADING_1));
      sections.push(...this.buildContentSection(content.financial_projections));
    }

    // Risk Management
    if (content.risk_management) {
      sections.push(this.buildHeading('Risk Management', HeadingLevel.HEADING_1));
      sections.push(...this.buildContentSection(content.risk_management));
    }

    return sections;
  }

  /**
   * Build BA document content
   */
  private buildBAContent(templateData: TemplateData): Paragraph[] {
    const sections: Paragraph[] = [];
    const content = templateData.content;

    // Introduction/Overview
    if (content.introduction || content.overview) {
      sections.push(this.buildHeading('Introduction', HeadingLevel.HEADING_1));
      sections.push(...this.buildContentSection(content.introduction ?? content.overview));
    }

    // Business Requirements
    if (content.business_requirements) {
      sections.push(this.buildHeading('Business Requirements', HeadingLevel.HEADING_1));
      sections.push(...this.buildContentSection(content.business_requirements));
    }

    // Functional Requirements
    if (content.functional_requirements) {
      sections.push(this.buildHeading('Functional Requirements', HeadingLevel.HEADING_1));
      sections.push(...this.buildContentSection(content.functional_requirements));
    }

    // User Stories
    if (content.user_stories) {
      sections.push(this.buildHeading('User Stories', HeadingLevel.HEADING_1));
      sections.push(...this.buildContentSection(content.user_stories));
    }

    // Process Flows
    if (content.process_flows) {
      sections.push(this.buildHeading('Process Flows', HeadingLevel.HEADING_1));
      sections.push(...this.buildContentSection(content.process_flows));
    }

    return sections;
  }

  /**
   * Build standards section for CTO documents
   */
  private buildStandardsSection(standards: StandardSection[]): Paragraph[] {
    const sections: Paragraph[] = [];

    sections.push(this.buildHeading('Engineering Standards', HeadingLevel.HEADING_1));

    for (const standard of standards) {
      sections.push(this.buildHeading(standard.title, HeadingLevel.HEADING_2));
      sections.push(this.buildParagraph(standard.description));

      for (const principle of standard.principles) {
        sections.push(this.buildHeading(principle.title, HeadingLevel.HEADING_3));
        sections.push(this.buildParagraph(principle.description));
      }
    }

    return sections;
  }

  /**
   * Build content section from nested object
   */
  private buildContentSection(content: unknown): Paragraph[] {
    const paragraphs: Paragraph[] = [];

    if (typeof content === 'string') {
      paragraphs.push(this.buildParagraph(content));
    } else if (Array.isArray(content)) {
      for (const item of content) {
        paragraphs.push(this.buildBulletPoint(String(item)));
      }
    } else if (typeof content === 'object' && content !== null) {
      for (const [key, value] of Object.entries(content)) {
        const label = this.formatLabel(key);
        if (typeof value === 'string' || typeof value === 'number') {
          paragraphs.push(this.buildLabeledParagraph(label, String(value)));
        } else if (Array.isArray(value)) {
          paragraphs.push(this.buildHeading(label, HeadingLevel.HEADING_3));
          for (const item of value) {
            paragraphs.push(this.buildBulletPoint(String(item)));
          }
        } else if (typeof value === 'object' && value !== null) {
          paragraphs.push(this.buildHeading(label, HeadingLevel.HEADING_2));
          paragraphs.push(...this.buildContentSection(value));
        }
      }
    }

    return paragraphs;
  }

  /**
   * Build a heading paragraph
   */
  private buildHeading(text: string, level: (typeof HeadingLevel)[keyof typeof HeadingLevel]): Paragraph {
    return new Paragraph({
      children: [new TextRun({ text, bold: true })],
      heading: level,
      spacing: { before: 240, after: 120 },
    });
  }

  /**
   * Build a regular paragraph
   */
  private buildParagraph(text: string): Paragraph {
    return new Paragraph({
      children: [new TextRun({ text })],
      spacing: { after: 120 },
    });
  }

  /**
   * Build a labeled paragraph (bold label: value)
   */
  private buildLabeledParagraph(label: string, value: string): Paragraph {
    return new Paragraph({
      children: [
        new TextRun({ text: `${label}: `, bold: true }),
        new TextRun({ text: value }),
      ],
      spacing: { after: 120 },
    });
  }

  /**
   * Build a bullet point
   */
  private buildBulletPoint(text: string): Paragraph {
    return new Paragraph({
      children: [new TextRun({ text })],
      bullet: { level: 0 },
      spacing: { after: 60 },
    });
  }

  /**
   * Build an empty paragraph for spacing
   */
  private buildEmptyParagraph(): Paragraph {
    return new Paragraph({ children: [], spacing: { after: 200 } });
  }

  /**
   * Build a simple two-column table
   */
  private buildTable(rows: string[][]): Table {
    return new Table({
      width: { size: 100, type: WidthType.PERCENTAGE },
      rows: rows.map(
        (row) =>
          new TableRow({
            children: row.map(
              (cell, index) =>
                new TableCell({
                  children: [
                    new Paragraph({
                      children: [
                        new TextRun({
                          text: cell,
                          bold: index === 0,
                        }),
                      ],
                    }),
                  ],
                  width: { size: index === 0 ? 30 : 70, type: WidthType.PERCENTAGE },
                  borders: {
                    top: { style: BorderStyle.SINGLE, size: 1 },
                    bottom: { style: BorderStyle.SINGLE, size: 1 },
                    left: { style: BorderStyle.SINGLE, size: 1 },
                    right: { style: BorderStyle.SINGLE, size: 1 },
                  },
                }),
            ),
          }),
      ),
    });
  }

  /**
   * Build document header
   */
  private buildHeader(title: string): Header {
    return new Header({
      children: [
        new Paragraph({
          children: [
            new TextRun({
              text: title,
              size: 20,
              color: '666666',
            }),
          ],
          alignment: AlignmentType.RIGHT,
        }),
      ],
    });
  }

  /**
   * Build document footer with page numbers
   */
  private buildFooter(): Footer {
    return new Footer({
      children: [
        new Paragraph({
          children: [
            new TextRun({
              text: 'Page ',
              size: 20,
            }),
            new TextRun({
              children: [PageNumber.CURRENT],
              size: 20,
            }),
            new TextRun({
              text: ' of ',
              size: 20,
            }),
            new TextRun({
              children: [PageNumber.TOTAL_PAGES],
              size: 20,
            }),
          ],
          alignment: AlignmentType.CENTER,
        }),
      ],
    });
  }

  /**
   * Get document styles
   */
  private getDocumentStyles() {
    return {
      default: {
        document: {
          run: {
            font: 'Calibri',
            size: 24, // 12pt
          },
          paragraph: {
            spacing: {
              line: 276, // 1.15 line spacing
            },
          },
        },
      },
    };
  }

  /**
   * Format a key to a human-readable label
   */
  private formatLabel(key: string): string {
    return key
      .replace(/_/g, ' ')
      .replace(/([a-z])([A-Z])/g, '$1 $2')
      .replace(/\b\w/g, (c) => c.toUpperCase());
  }
}

```

## c:\Users\avi\OneDrive - BAS & More\Qoder Repo\Quiz-to-build\Quiz-to-build\docker\api\Dockerfile
```
# Build stage - Using Debian slim for better Prisma/OpenSSL compatibility
FROM node:20-bookworm-slim AS builder

WORKDIR /app

# Install OpenSSL (required by Prisma)
RUN apt-get update && apt-get install -y --no-install-recommends \
    openssl \
    && rm -rf /var/lib/apt/lists/*

# Install dependencies
COPY package*.json ./
COPY apps/api/package*.json ./apps/api/
COPY libs/database/package*.json ./libs/database/
COPY libs/redis/package*.json ./libs/redis/
COPY libs/shared/package*.json ./libs/shared/

RUN npm ci

# Copy source files
COPY . .

# Generate Prisma client
RUN npx prisma generate

# Build only the API for production
RUN cd apps/api && npx nest build

# Production stage
FROM node:20-bookworm-slim AS production

WORKDIR /app

# Install OpenSSL and other required libraries for Prisma
RUN apt-get update && apt-get install -y --no-install-recommends \
    openssl \
    ca-certificates \
    wget \
    && rm -rf /var/lib/apt/lists/*

# Create non-root user for security
RUN groupadd -g 1001 nodejs && \
    useradd -m -u 1001 -g nodejs nestjs

# Copy built application
COPY --from=builder --chown=nestjs:nodejs /app/apps/api/dist ./dist
COPY --from=builder --chown=nestjs:nodejs /app/node_modules ./node_modules
COPY --from=builder --chown=nestjs:nodejs /app/package*.json ./
COPY --from=builder --chown=nestjs:nodejs /app/prisma ./prisma
COPY --from=builder --chown=nestjs:nodejs /app/tsconfig.json ./tsconfig.json

# Copy libs with compiled dist directories for path resolution
COPY --from=builder --chown=nestjs:nodejs /app/libs ./libs

# Copy entrypoint script
COPY --chown=nestjs:nodejs docker/api/entrypoint.sh ./entrypoint.sh
RUN chmod +x ./entrypoint.sh

# Switch to non-root user
USER nestjs

# Expose port
EXPOSE 3000

# Health check
HEALTHCHECK --interval=30s --timeout=10s --start-period=5s --retries=3 \
    CMD wget --no-verbose --tries=1 --spider http://localhost:3000/api/v1/health || exit 1

# Start the application
CMD ["./entrypoint.sh"]

# Development stage
FROM node:20-bookworm-slim AS development

WORKDIR /app

# Install OpenSSL (required by Prisma)
RUN apt-get update && apt-get install -y openssl && rm -rf /var/lib/apt/lists/*

# Install dependencies
COPY package*.json ./
COPY apps/api/package*.json ./apps/api/
COPY libs/database/package*.json ./libs/database/
COPY libs/redis/package*.json ./libs/redis/
COPY libs/shared/package*.json ./libs/shared/

RUN npm ci

# Copy source files
COPY . .

# Generate Prisma client
RUN npx prisma generate

# Expose port
EXPOSE 3000

# Start in development mode
CMD ["npm", "run", "start:dev"]

```

## c:\Users\avi\OneDrive - BAS & More\Qoder Repo\Quiz-to-build\Quiz-to-build\infrastructure\terraform\modules\database\main.tf
```
# Database Module - Azure Database for PostgreSQL Flexible Server

resource "random_password" "postgres" {
  length           = 32
  special          = true
  override_special = "!#$%&*()-_=+[]{}<>:?"
}

resource "azurerm_postgresql_flexible_server" "main" {
  name                   = "psql-${var.project_name}-${var.environment}"
  resource_group_name    = var.resource_group_name
  location               = var.location
  version                = var.postgresql_version
  delegated_subnet_id    = var.subnet_id
  private_dns_zone_id    = var.private_dns_zone_id
  administrator_login    = "psqladmin"
  administrator_password = random_password.postgres.result
  zone                   = "1"
  storage_mb             = var.storage_mb
  sku_name               = var.sku_name
  backup_retention_days  = 7

<<<<<<< Local
  # High availability disabled for dev - uncomment for production:
  # high_availability {
  #   mode = "ZoneRedundant"
  # }

  tags = var.tags

  lifecycle {
    ignore_changes = [
      zone
    ]
=======
  # Note: For production, add high_availability block with mode = "ZoneRedundant"

  tags = var.tags

  lifecycle {
    ignore_changes = [
      zone,
      high_availability[0].standby_availability_zone
    ]
>>>>>>> Remote
  }
}

resource "azurerm_postgresql_flexible_server_database" "main" {
  name      = var.db_name
  server_id = azurerm_postgresql_flexible_server.main.id
  collation = "en_US.utf8"
  charset   = "UTF8"
}

# Configure server parameters for better performance
resource "azurerm_postgresql_flexible_server_configuration" "timezone" {
  name      = "timezone"
  server_id = azurerm_postgresql_flexible_server.main.id
  value     = "UTC"
}

resource "azurerm_postgresql_flexible_server_configuration" "log_connections" {
  name      = "log_connections"
  server_id = azurerm_postgresql_flexible_server.main.id
  value     = "on"
}

resource "azurerm_postgresql_flexible_server_configuration" "log_disconnections" {
  name      = "log_disconnections"
  server_id = azurerm_postgresql_flexible_server.main.id
  value     = "on"
}

```

## c:\Users\avi\OneDrive - BAS & More\Qoder Repo\Quiz-to-build\Quiz-to-build\infrastructure\terraform\providers.tf
```
terraform {
  required_version = ">= 1.5.0"

  required_providers {
    azurerm = {
      source  = "hashicorp/azurerm"
      version = "~> 3.85.0"
    }
    random = {
      source  = "hashicorp/random"
      version = "~> 3.6.0"
    }
  }
}

provider "azurerm" {
  skip_provider_registration = true
  features {
    key_vault {
      purge_soft_delete_on_destroy    = true
      recover_soft_deleted_key_vaults = true
    }
    resource_group {
      prevent_deletion_if_contains_resources = false
    }
  }

  # Skip auto-registration of deprecated providers
  skip_provider_registration = true
}

provider "random" {}

```

## c:\Users\avi\OneDrive - BAS & More\Qoder Repo\Quiz-to-build\Quiz-to-build\infrastructure\terraform\variables.tf
```
variable "project_name" {
  description = "Name of the project, used in resource naming"
  type        = string
  default     = "questionnaire"
}

variable "environment" {
  description = "Environment name (dev, staging, prod)"
  type        = string
  default     = "dev"
}

variable "location" {
  description = "Azure region for resources"
  type        = string
  default     = "australiaeast" # Changed from eastus due to PostgreSQL quota restrictions
}

variable "tags" {
  description = "Tags to apply to all resources"
  type        = map(string)
  default = {
    Project     = "Adaptive Questionnaire System"
    ManagedBy   = "Terraform"
    Environment = "Development"
  }
}

# Networking
variable "vnet_address_space" {
  description = "Address space for the virtual network"
  type        = list(string)
  default     = ["10.0.0.0/16"]
}

variable "subnet_app_prefix" {
  description = "Address prefix for the application subnet"
  type        = string
  default     = "10.0.1.0/24"
}

variable "subnet_db_prefix" {
  description = "Address prefix for the database subnet"
  type        = string
  default     = "10.0.2.0/24"
}

variable "subnet_cache_prefix" {
  description = "Address prefix for the cache subnet"
  type        = string
  default     = "10.0.3.0/24"
}

# Database
variable "postgresql_sku_name" {
  description = "SKU name for PostgreSQL Flexible Server"
  type        = string
  default     = "B_Standard_B1ms"
}

variable "postgresql_storage_mb" {
  description = "Storage size in MB for PostgreSQL"
  type        = number
  default     = 32768
}

variable "postgresql_version" {
  description = "PostgreSQL version"
  type        = string
  default     = "15"
}

variable "db_name" {
  description = "Name of the application database"
  type        = string
  default     = "questionnaire"
}

# Redis
variable "redis_sku_name" {
  description = "SKU name for Redis Cache"
  type        = string
  default     = "Standard"
}

variable "redis_capacity" {
  description = "Redis cache capacity (0-6 for Basic/Standard)"
  type        = number
  default     = 0
}

variable "redis_family" {
  description = "Redis cache family (C for Basic/Standard)"
  type        = string
  default     = "C"
}

# Container Apps
variable "container_cpu" {
  description = "CPU allocation for container (in cores)"
  type        = number
  default     = 0.5
}

variable "container_memory" {
  description = "Memory allocation for container"
  type        = string
  default     = "1Gi"
}

variable "container_min_replicas" {
  description = "Minimum number of container replicas"
  type        = number
  default     = 1
}

variable "container_max_replicas" {
  description = "Maximum number of container replicas"
  type        = number
  default     = 3
}

# Container Registry
variable "acr_sku" {
  description = "SKU for Azure Container Registry"
  type        = string
  default     = "Basic"
}

```

## c:\Users\avi\OneDrive - BAS & More\Qoder Repo\Quiz-to-build\Quiz-to-build\.gitignore
```
# Dependencies
node_modules/

# Build output
dist/
build/

# IDE
.idea/
.vscode/
*.swp
*.swo

# Environment
.env
.env.local
.env.*.local

# Logs
logs/
*.log
npm-debug.log*

# Testing
coverage/
.nyc_output/

# OS files
.DS_Store
Thumbs.db

# Prisma
prisma/*.db
prisma/*.db-journal

# Turbo
.turbo/

# Docker
docker/postgres/data/

# Temporary files
tmp/
temp/
*.tmp

# Editor directories
*.sublime-workspace
*.sublime-project

# Terraform
infrastructure/terraform/.terraform/
*.tfstate
*.tfstate.*
*.tfvars
!*.tfvars.example
.terraform.lock.hcl
crash.log
crash.*.log
override.tf
override.tf.json
*_override.tf
*_override.tf.json

```

## c:\Users\avi\OneDrive - BAS & More\Qoder Repo\Quiz-to-build\Quiz-to-build\.vscode\settings.json
```
{
    "redhat.telemetry.enabled": false,
    "redHatDependencyAnalytics.exhortSnykToken": "",
    "redHatDependencyAnalytics.matchManifestVersions": false,
    "files.exclude": {
        "**/node_modules": true
    },
    "search.exclude": {
        "**/node_modules": true,
        "**/dist": true,
        "**/.turbo": true
    }
}
```

## c:\Users\avi\OneDrive - BAS & More\Qoder Repo\Quiz-to-build\Quiz-to-build\apps\api\src\modules\adaptive-logic\adaptive-logic.service.ts
```
import { Injectable } from '@nestjs/common';
import { PrismaService } from '@libs/database';
import { Question, VisibilityRule, VisibilityAction } from '@prisma/client';
import { ConditionEvaluator } from './evaluators/condition.evaluator';
import { Condition, LogicalOperator } from './types/rule.types';

export interface QuestionState {
  visible: boolean;
  required: boolean;
  disabled: boolean;
}

export interface EvaluationResult {
  questionId: string;
  state: QuestionState;
  appliedRules: string[];
}

@Injectable()
export class AdaptiveLogicService {
  constructor(
    private readonly prisma: PrismaService,
    private readonly conditionEvaluator: ConditionEvaluator,
  ) { }

  /**
   * Get all visible questions for a questionnaire based on current responses
   */
  async getVisibleQuestions(
    questionnaireId: string,
    responses: Map<string, unknown>,
  ): Promise<Question[]> {
    // Get all questions with their visibility rules
    const questions = await this.prisma.question.findMany({
      where: {
        section: {
          questionnaireId,
        },
      },
      include: {
        visibilityRules: {
          where: { isActive: true },
          orderBy: { priority: 'desc' },
        },
        section: true,
      },
      orderBy: [
        { section: { orderIndex: 'asc' } },
        { orderIndex: 'asc' },
      ],
    });

    // Evaluate visibility for each question
    const visibleQuestions: Question[] = [];

    for (const question of questions) {
      const state = this.evaluateQuestionState(question, responses);
      if (state.visible) {
        visibleQuestions.push(question);
      }
    }

    return visibleQuestions;
  }

  /**
   * Evaluate the state of a specific question
   */
  evaluateQuestionState(
    question: Question & { visibilityRules?: VisibilityRule[] },
    responses: Map<string, unknown>,
  ): QuestionState {
    // Default state
    let state: QuestionState = {
      visible: true,
      required: question.isRequired,
      disabled: false,
    };

    // If no visibility rules, return default state
    if (!question.visibilityRules || question.visibilityRules.length === 0) {
      return state;
    }

    // Evaluate each rule in priority order (highest first)
    const sortedRules = [...question.visibilityRules].sort(
      (left, right) => (right.priority ?? 0) - (left.priority ?? 0),
    );
    let visibilityResolved = false;
    let requiredResolved = false;

    for (const rule of sortedRules) {
      const condition = rule.condition as Condition;
      const ruleResult = this.evaluateCondition(condition, responses);

      if (ruleResult) {
        // Apply the rule's action
        switch (rule.action) {
          case VisibilityAction.SHOW:
            if (!visibilityResolved) {
              state.visible = true;
              visibilityResolved = true;
            }
            break;
          case VisibilityAction.HIDE:
            if (!visibilityResolved) {
              state.visible = false;
              visibilityResolved = true;
            }
            break;
          case VisibilityAction.REQUIRE:
            if (!requiredResolved) {
              state.required = true;
              requiredResolved = true;
            }
            break;
          case VisibilityAction.UNREQUIRE:
            if (!requiredResolved) {
              state.required = false;
              requiredResolved = true;
            }
            break;
        }

        if (visibilityResolved && requiredResolved) {
          break;
        }
      }
    }

    return state;
  }

  /**
   * Get the next question in the flow based on branching rules
   */
  async getNextQuestion(
    currentQuestionId: string,
    responses: Map<string, unknown>,
  ): Promise<Question | null> {
    // Get current question
    const currentQuestion = await this.prisma.question.findUnique({
      where: { id: currentQuestionId },
      include: {
        section: {
          include: {
            questionnaire: true,
          },
        },
        visibilityRules: {
          where: { isActive: true },
        },
      },
    });

    if (!currentQuestion) {
      return null;
    }

    // Get all visible questions
    const visibleQuestions = await this.getVisibleQuestions(
      currentQuestion.section.questionnaireId,
      responses,
    );

    // Find current position and return next
    const currentIndex = visibleQuestions.findIndex((q) => q.id === currentQuestionId);

    if (currentIndex === -1 || currentIndex >= visibleQuestions.length - 1) {
      return null;
    }

    return visibleQuestions[currentIndex + 1];
  }

  /**
   * Evaluate a condition against responses
   */
  evaluateCondition(condition: Condition, responses: Map<string, unknown>): boolean {
    return this.conditionEvaluator.evaluate(condition, responses);
  }

  /**
   * Evaluate multiple conditions with a logical operator
   */
  evaluateConditions(
    conditions: Condition[],
    operator: LogicalOperator,
    responses: Map<string, unknown>,
  ): boolean {
    if (conditions.length === 0) {
      return true;
    }

    const results = conditions.map((c) => this.evaluateCondition(c, responses));

    if (operator === 'AND') {
      return results.every((r) => r);
    } else {
      return results.some((r) => r);
    }
  }

  /**
   * Calculate which questions were added or removed due to a response change
   */
  async calculateAdaptiveChanges(
    questionnaireId: string,
    previousResponses: Map<string, unknown>,
    currentResponses: Map<string, unknown>,
  ): Promise<{ added: string[]; removed: string[] }> {
    const previousVisible = await this.getVisibleQuestions(questionnaireId, previousResponses);
    const currentVisible = await this.getVisibleQuestions(questionnaireId, currentResponses);

    const previousIds = new Set(previousVisible.map((q) => q.id));
    const currentIds = new Set(currentVisible.map((q) => q.id));

    const added = currentVisible.filter((q) => !previousIds.has(q.id)).map((q) => q.id);
    const removed = previousVisible.filter((q) => !currentIds.has(q.id)).map((q) => q.id);

    return { added, removed };
  }

  /**
   * Get all rules that affect a specific question
   */
  async getRulesForQuestion(questionId: string): Promise<VisibilityRule[]> {
    return this.prisma.visibilityRule.findMany({
      where: {
        OR: [
          { questionId },
          { targetQuestionIds: { has: questionId } },
        ],
        isActive: true,
      },
      orderBy: { priority: 'desc' },
    });
  }

  /**
   * Build a dependency graph for questions
   */
  async buildDependencyGraph(
    questionnaireId: string,
  ): Promise<Map<string, Set<string>>> {
    const rules = await this.prisma.visibilityRule.findMany({
      where: {
        question: {
          section: {
            questionnaireId,
          },
        },
        isActive: true,
      },
    });

    const graph = new Map<string, Set<string>>();

    for (const rule of rules) {
      const condition = rule.condition as Condition;
      const sourceQuestionId = this.extractQuestionIdFromCondition(condition);

      if (sourceQuestionId) {
        for (const targetId of rule.targetQuestionIds) {
          if (!graph.has(sourceQuestionId)) {
            graph.set(sourceQuestionId, new Set());
          }
          graph.get(sourceQuestionId)!.add(targetId);
        }
      }
    }

    return graph;
  }

  private extractQuestionIdFromCondition(condition: Condition): string | null {
    if (condition.field) {
      return condition.field;
    }
    if (condition.nested && condition.nested.length > 0) {
      return this.extractQuestionIdFromCondition(condition.nested[0]);
    }
    return null;
  }
}

```

